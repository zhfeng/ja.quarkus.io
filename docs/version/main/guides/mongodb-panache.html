<!DOCTYPE html>
<html>





<head>
  <title>Quarkus - シンプルになったMongoDB with Panache - main</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src https://dpm.demdex.net; script-src 'self' 'unsafe-eval' 'sha256-ANpuoVzuSex6VhqpYgsG25OHWVA1I+F6aGU04LoI+5s=' 'sha256-ipy9P/3rZZW06mTLAR0EnXvxSNcnfSDPLDuh3kzbB1w=' js.bizographics.com https://www.redhat.com https://static.redhat.com assets.adobedtm.com jsonip.com https://ajax.googleapis.com https://www.googletagmanager.com https://www.google-analytics.com https://use.fontawesome.com https://app.mailjet.com http://www.youtube.com http://www.googleadservices.com https://googleads.g.doubleclick.net https://dpm.demdex.net https://giscus.app; style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; img-src 'self' *; media-src 'self'; frame-src https://www.googletagmanager.com https://www.youtube.com https://embed.restream.io https://app.mailjet.com https://giscus.app; base-uri 'none'; object-src 'none'; form-action 'none'; font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/version/main/guides/mongodb-panache" />
  <meta property="og:title" content="シンプルになったMongoDB with Panache - main" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/mongodb-panache">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/goan.js" type="text/javascript"></script>
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
</head>

<body class="guides">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJWS5L"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
  <div class="container">
    <div class="logo-wrapper">
        <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
    </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="/about/">Quarkusとは <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/continuum" class="">リアクティブ</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="/learn/">学ぶ<i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ガイド</a></li>
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="/community/">コミュニティ <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="/publications" class="">出版物</a></li>
          <li><a href="/awards" class="">受賞</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/" >ENGLISH</a></li>
          <li><a href="https://ja.quarkus.io/">JAPANESE</a></li>
          </ul>
      </li>
    </ul>
  </div>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    



<div class="full-width-version-bg grey align-self">
  <div class="grid-wrapper">
    <div class="grid__item width-6-12">
      <p class="returnlink"><i class="fas fa-angle-left"></i><a href="/version/main/guides/"> Back to Guides</a></p>
    </div>
    <div class="grid__item width-6-12 align-self-center text-right hide-mobile">
      <label id="guide-version-label">Select Guide Version</label>
      <select id="guide-version-dropdown">
        
      
        
        
        
        
          
        <option value="main" selected>Main - SNAPSHOT</option>
        
        
      
        
        
        
        
          
        <option value="latest" >2.9 - Latest</option>
        
        
      
        
        
        
        
          
        <option value="2.7" >2.7</option>
        
        
      
        
        
        
        
          
        <option value="2.2" >2.2</option>
        
        
      
        
        
        
        
          
        <option value="1.11" >1.11</option>
        
        
      
    
      </select>
    </div>
  </div>
</div>

<div class="grid-wrapper guide">
  <div class="grid__item width-12-12 width-12-12-mobile">
    <h1 class="text-caps">シンプルになったMongoDB with Panache </h1>
  </div>
  <div class="width-12-12">
    <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#最初に例">最初に:例</a></li>
<li><a href="#ソリューション">ソリューション</a></li>
<li><a href="#creating-the-maven-project">Creating the Maven project</a></li>
<li><a href="#setting-up-and-configuring-mongodb-with-panache">Setting up and configuring MongoDB with Panache</a></li>
<li><a href="#解決策1アクティブレコードパターンを使用する">解決策1:アクティブレコードパターンを使用する</a>
<ul class="sectlevel2">
<li><a href="#エンティティの定義">エンティティの定義</a></li>
<li><a href="#最も便利な操作">最も便利な操作</a></li>
<li><a href="#エンティティメソッドの追加">エンティティメソッドの追加</a></li>
</ul>
</li>
<li><a href="#解決策2リポジトリパターンの使用">解決策2：リポジトリパターンの使用</a>
<ul class="sectlevel2">
<li><a href="#エンティティの定義-2">エンティティの定義</a></li>
<li><a href="#リポジトリの定義">リポジトリの定義</a></li>
<li><a href="#最も便利な操作-2">最も便利な操作</a></li>
</ul>
</li>
<li><a href="#writing-a-jax-rs-resource">Writing a JAX-RS resource</a></li>
<li><a href="#アドバンスドクエリー">アドバンスドクエリー</a>
<ul class="sectlevel2">
<li><a href="#ページング">ページング</a></li>
<li><a href="#ページではなく範囲を使用する">ページではなく範囲を使用する</a></li>
<li><a href="#ソート">ソート</a></li>
<li><a href="#シンプルなクエリ">シンプルなクエリ</a></li>
<li><a href="#クエリパラメーター">クエリパラメーター</a></li>
<li><a href="#クエリの投影">クエリの投影</a></li>
</ul>
</li>
<li><a href="#クエリのデバッグ">クエリのデバッグ</a></li>
<li><a href="#pojocodecprovider-オブジェクトからbsonドキュメントへの変換を簡単に行うことができます">PojoCodecProvider: オブジェクトからBSONドキュメントへの変換を簡単に行うことができます。</a></li>
<li><a href="#トランザクション">トランザクション</a></li>
<li><a href="#カスタムid">カスタムID</a></li>
<li><a href="#working-with-kotlin-data-classes">Working with Kotlin Data classes</a></li>
<li><a href="#reactive">リアクティブエンティティとレポジトリー</a></li>
<li><a href="#モック">モック</a>
<ul class="sectlevel2">
<li><a href="#アクティブレコードパターンの使用">アクティブ・レコード・パターンの使用</a></li>
<li><a href="#リポジトリパターンの使用">リポジトリパターンの使用</a></li>
</ul>
</li>
<li><a href="#how-and-why-we-simplify-mongodb-api">How and why we simplify MongoDB API</a></li>
<li><a href="#外部プロジェクトや-jar-でエンティティーを定義する">外部プロジェクトや jar でエンティティーを定義する</a></li>
</ul></div>
    <div>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>MongoDBは広く利用されている有名なNoSQLデータベースですが、エンティティとクエリをMongoDB <a href="https://mongodb.github.io/mongo-java-driver/4.2/bson/documents/#document"><code>Document</code></a> として表現する必要があるため、生のAPIを使用するのは面倒です。</p>
</div>
<div class="paragraph">
<p>MongoDB with Panacheは、 <a href="hibernate-orm-panache.html">Hibernate ORM with Panache</a>にあるようなアクティブレコードスタイルのエンティティ（およびリポジトリ）を提供し、Quarkusでエンティティを簡単に楽しく書けるようにすることに重点を置いています。</p>
</div>
<div class="paragraph">
<p>これは、 <a href="mongodb.html">MongoDB Client</a>エクステンションの上に構築されています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="最初に例"><a class="anchor" href="#最初に例"></a>最初に:例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Panacheでは、MongoDBのエンティティをこのように書くことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person extends PanacheMongoEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List&lt;Person&gt; findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteLoics(){
        delete("name", "Loïc");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>MongoDBのAPIを使った場合と比べて、コードがどれだけコンパクトで読みやすくなったかお気づきでしょうか？これは面白いと思いませんか？読んでみてください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>list()</code> の方法は、最初は驚くかもしれません。これは、PanacheQLのクエリ（JPQLのサブセット）の断片を取り出し、残りの部分を文脈化したものです。これにより、非常に簡潔でありながら読みやすいコードになっています。MongoDBのネイティブクエリもサポートしています。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上で説明したものは基本的に <a href="https://www.martinfowler.com/eaaCatalog/activeRecord.html">アクティブレコードパターン</a>で、単にエンティティパターンと呼ばれることもあります。MongoDB with Panacheでは、 <code>PanacheMongoRepository</code> を通じて、より古典的な <a href="https://martinfowler.com/eaaCatalog/repository.html">リポジトリパターン</a>を使うこともできます。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ソリューション"><a class="anchor" href="#ソリューション"></a>ソリューション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</p>
</div>
<div class="paragraph">
<p>Gitレポジトリをクローンするか <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code> 、 <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">アーカイブ</a> をダウンロードします。</p>
</div>
<div class="paragraph">
<p>ソリューションは <code>mongodb-panache-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/mongodb-panache-quickstart">directory</a> にあります。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-the-maven-project"><a class="anchor" href="#creating-the-maven-project"></a>Creating the Maven project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</p>
</div>
<div class="sidebarblock primary asciidoc-tabs-sync-cli">
<div class="content">
<div class="title">CLI</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">quarkus create app org.acme:mongodb-panache-quickstart \
    --extension=resteasy-reactive-jackson,mongodb-panache \
    --no-code
cd mongodb-panache-quickstart</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a Gradle project, add the <code>--gradle</code> or <code>--gradle-kotlin-dsl</code> option.</p>
</div>
<div class="paragraph">
<p><em>For more information about how to install the Quarkus CLI and use it, please refer to <a href="cli-tooling">the Quarkus CLI guide</a>.</em></p>
</div>
</div>
</div>
<div class="sidebarblock secondary asciidoc-tabs-sync-maven">
<div class="content">
<div class="title">Maven</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn io.quarkus.platform:quarkus-maven-plugin:999-SNAPSHOT:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=mongodb-panache-quickstart \
    -Dextensions="resteasy-reactive-jackson,mongodb-panache" \
    -DnoCode
cd mongodb-panache-quickstart</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a Gradle project, add the <code>-DbuildTool=gradle</code> or <code>-DbuildTool=gradle-kotlin-dsl</code> option.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>このコマンドは、RESTEasy Reactive JacksonとMongoDB with PanacheエクステンションをインポートするMaven構造を生成します。この後、 <code>quarkus-mongodb-panache</code> エクステンションがビルドファイルに追加されています。</p>
</div>
<div class="paragraph">
<p>新しいプロジェクトを生成したくない場合は、ビルドファイルに依存関係を追加してください。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-mongodb-panache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-mongodb-panache")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-and-configuring-mongodb-with-panache"><a class="anchor" href="#setting-up-and-configuring-mongodb-with-panache"></a>Setting up and configuring MongoDB with Panache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>始めるには</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>application.properties</code> に設定を追加します。</p>
</li>
<li>
<p>エンティティが <code>PanacheMongoEntity</code> を継承するようにする（リポジトリパターンを使用している場合はオプション）。</p>
</li>
<li>
<p>オプションとして、 <code>@MongoEntity</code> アノテーションを使用して、コレクションの名前、データベースの名前、またはクライアントの名前を指定します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次に、関連する構成プロパティを <code>application.properties</code> に追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># configure the MongoDB client for a replica set of two nodes
quarkus.mongodb.connection-string = mongodb://mongo1:27017,mongo2:27017
# mandatory if you don't specify the name of the database using @MongoEntity
quarkus.mongodb.database = person</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>quarkus.mongodb.database</code> プロパティは、MongoDB with Panache でエンティティを永続化するデータベースの名前を決定するのに使われます（ <code>@MongoEntity</code> でオーバーライドされていない場合）。</p>
</div>
<div class="paragraph">
<p><code>@MongoEntity</code> のアノテーションでは次の設定が可能です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>マルチテナントアプリケーション用のクライアントの名前を指定することもできます。 <a href="mongodb#multiple-mongodb-clients">Multiple MongoDB Clients</a> を参照してください。それ以外の場合は、デフォルトのクライアントを使います。</p>
</li>
<li>
<p>データベースの名前。そうでない場合は <code>quarkus.mongodb.database</code> プロパティが使用されます。</p>
</li>
<li>
<p>コレクションの名前。そうでない場合はクラスのシンプルな名前が使われます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>MongoDBクライアントの高度な設定については、 <a href="mongodb.html#configuring-the-mongodb-database">Configuring the MongoDB database ガイド</a>に従ってください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="解決策1アクティブレコードパターンを使用する"><a class="anchor" href="#解決策1アクティブレコードパターンを使用する"></a>解決策1:アクティブレコードパターンを使用する</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="エンティティの定義"><a class="anchor" href="#エンティティの定義"></a>エンティティの定義</h3>
<div class="paragraph">
<p>Panacheのエンティティを定義するには、 <code>PanacheMongoEntity</code> を拡張して、カラムをパブリックフィールドとして追加するだけです。コレクション、データベース、またはクライアントの名前をカスタマイズする必要がある場合は、 <code>@MongoEntity</code> アノテーションをエンティティに追加することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MongoEntity(collection="ThePerson")
public class Person extends PanacheMongoEntity {
    public String name;

    // will be persisted as a 'birth' field in MongoDB
    @BsonProperty("birth")
    public LocalDate birthDate;

    public Status status;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@MongoEntity</code> でのアノテーションはオプションです。ここでは、エンティティは、デフォルトの <code>Person</code> コレクションではなく、 <code>ThePerson</code> コレクションに保存されます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>MongoDB with Panacheでは、 <a href="https://mongodb.github.io/mongo-java-driver/4.2/bson/pojos/">PojoCodecProvider</a>を使ってエンティティをMongoDB <code>Document</code> に変換します。</p>
</div>
<div class="paragraph">
<p>このマッピングをカスタマイズするために、以下のアノテーションを使用することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BsonId</code>: IDフィールドをカスタマイズすることができます。「 <a href="#custom-ids">カスタムID</a>」を参照してください。</p>
</li>
<li>
<p><code>@BsonProperty</code>: フィールドのシリアル化された名前をカスタマイズします。</p>
</li>
<li>
<p><code>@BsonIgnore</code>: シリアル化の際にフィールドを無視することができます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>アクセサを書く必要がある場合は、以下のようにできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person extends PanacheMongoEntity {

    @JsonProperty
    public String name;
    public LocalDate birth;
    public Status status;

    // return name as uppercase in the model
    public String getName(){
        return name.toUpperCase();
    }

    // store all names in lowercase in the DB
    public void setName(String name){
        this.name = name.toLowerCase();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、当社のフィールドアクセスリライトのおかげで、ユーザーが <code>person.name</code> を読むときには、実際に <code>getName()</code> アクセサが呼び出されます。これはフィールドの書き込みやセッターについても同様です。これにより、すべてのフィールドの呼び出しが、対応するゲッター/セッターの呼び出しに置き換えられるため、実行時に適切なカプセル化が可能になります。</p>
</div>
</div>
<div class="sect2">
<h3 id="最も便利な操作"><a class="anchor" href="#最も便利な操作"></a>最も便利な操作</h3>
<div class="paragraph">
<p>エンティティーを記述したら、ここでは実行できる最も一般的な操作を紹介します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// creating a person
Person person = new Person();
person.name = "Loïc";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;

// persist it: if you keep the default ObjectId ID field, it will be populated by the MongoDB driver
person.persist();

person.status = Status.Dead;

// Your must call update() in order to send your entity modifications to MongoDB
person.update();

// delete it
person.delete();

// getting a list of all Person entities
List&lt;Person&gt; allPersons = Person.listAll();

// finding a specific person by ID
// here we build a new ObjectId but you can also retrieve it from the existing entity after being persisted
ObjectId personId = new ObjectId(idAsString);
person = Person.findById(personId);

// finding a specific person by ID via an Optional
Optional&lt;Person&gt; optional = Person.findByIdOptional(personId);
person = optional.orElseThrow(() -&gt; new NotFoundException());

// finding all living persons
List&lt;Person&gt; livingPersons = Person.list("status", Status.Alive);

// counting all persons
long countAll = Person.count();

// counting all living persons
long countAlive = Person.count("status", Status.Alive);

// delete all living persons
Person.delete("status", Status.Alive);

// delete all persons
Person.deleteAll();

// delete by id
boolean deleted = Person.deleteById(personId);

// set the name of all living persons to 'Mortal'
long updated = Person.update("name", "Mortal").where("status", Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p>すべての <code>list</code> メソッドは、同等の <code>stream</code> バージョンがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stream&lt;Person&gt; persons = Person.streamAll();
List&lt;String&gt; namesButEmmanuels = persons
    .map(p -&gt; p.name.toLowerCase() )
    .filter( n -&gt; ! "emmanuel".equals(n) )
    .collect(Collectors.toList());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>persistOrUpdate()</code> メソッドは、データベース内のエンティティを永続化または更新するために存在し、MongoDB の _upsert_機能を使用して単一のクエリでそれを行います。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="エンティティメソッドの追加"><a class="anchor" href="#エンティティメソッドの追加"></a>エンティティメソッドの追加</h3>
<div class="paragraph">
<p>エンティティに対するカスタムクエリを、エンティティ自体の中に追加できます。そうすることで、自分や同僚が簡単に見つけることができ、クエリは操作するオブジェクトと一緒に配置されます。エンティティクラスにスタティックメソッドとして追加するのがPanache Active Recordのやり方です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person extends PanacheMongoEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List&lt;Person&gt; findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteLoics(){
        delete("name", "Loïc");
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="解決策2リポジトリパターンの使用"><a class="anchor" href="#解決策2リポジトリパターンの使用"></a>解決策2：リポジトリパターンの使用</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="エンティティの定義-2"><a class="anchor" href="#エンティティの定義-2"></a>エンティティの定義</h3>
<div class="paragraph">
<p>エンティティは通常のPOJOとして定義することができます。コレクション、データベース、またはクライアントの名前をカスタマイズする必要がある場合は、 <code>@MongoEntity</code> アノテーションをエンティティに追加できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MongoEntity(collection="ThePerson")
public class Person  {
    public ObjectId id; // used by MongoDB for the _id field
    public String name;
    public LocalDate birth;
    public Status status;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@MongoEntity</code> でのアノテーションはオプションです。ここでは、エンティティは、デフォルトの <code>Person</code> コレクションではなく、 <code>ThePerson</code> コレクションに保存されます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>MongoDB with Panacheでは、 <a href="https://mongodb.github.io/mongo-java-driver/4.2/bson/pojos/">PojoCodecProvider</a>を使ってエンティティをMongoDB <code>Document</code> に変換します。</p>
</div>
<div class="paragraph">
<p>このマッピングをカスタマイズするために、以下のアノテーションを使用することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BsonId</code>: IDフィールドをカスタマイズすることができます。「 <a href="#custom-ids">カスタムID</a>」を参照してください。</p>
</li>
<li>
<p><code>@BsonProperty</code>: フィールドのシリアル化された名前をカスタマイズします。</p>
</li>
<li>
<p><code>@BsonIgnore</code>: シリアル化の際にフィールドを無視することができます。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
ゲッターやセッターを使って、パブリックフィールドやプライベートフィールドを使うことができます。IDを自分で管理したくない場合は、 <code>PanacheMongoEntity</code> を拡張したエンティティを作ることができます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="リポジトリの定義"><a class="anchor" href="#リポジトリの定義"></a>リポジトリの定義</h3>
<div class="paragraph">
<p>リポジトリを使用する場合、<code>PanacheMongoRepository</code> を実装することでリポジトリに注入されたアクティブレコードパターンのウィットと全く同じ便利なメソッドが得られます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class PersonRepository implements PanacheMongoRepository&lt;Person&gt; {

   // put your custom logic here as instance methods

   public Person findByName(String name){
       return find("name", name).firstResult();
   }

   public List&lt;Person&gt; findAlive(){
       return list("status", Status.Alive);
   }

   public void deleteLoics(){
       delete("name", "Loïc");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PanacheMongoEntityBase</code> で定義されているすべての操作は、あなたのリポジトリで利用できます。そのため、これを使用することは、注入する必要があることを除けば、active record パターンを使用することとまったく同じです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
PersonRepository personRepository;

@GET
public long count(){
    return personRepository.count();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="最も便利な操作-2"><a class="anchor" href="#最も便利な操作-2"></a>最も便利な操作</h3>
<div class="paragraph">
<p>リポジトリを書くことで実行可能な最も一般的な操作は以下の通りです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// creating a person
Person person = new Person();
person.name = "Loïc";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;

// persist it: if you keep the default ObjectId ID field, it will be populated by the MongoDB driver
personRepository.persist(person);

person.status = Status.Dead;

// Your must call update() in order to send your entity modifications to MongoDB
personRepository.update(person);

// delete it
personRepository.delete(person);

// getting a list of all Person entities
List&lt;Person&gt; allPersons = personRepository.listAll();

// finding a specific person by ID
// here we build a new ObjectId but you can also retrieve it from the existing entity after being persisted
ObjectId personId = new ObjectId(idAsString);
person = personRepository.findById(personId);

// finding a specific person by ID via an Optional
Optional&lt;Person&gt; optional = personRepository.findByIdOptional(personId);
person = optional.orElseThrow(() -&gt; new NotFoundException());

// finding all living persons
List&lt;Person&gt; livingPersons = personRepository.list("status", Status.Alive);

// counting all persons
long countAll = personRepository.count();

// counting all living persons
long countAlive = personRepository.count("status", Status.Alive);

// delete all living persons
personRepository.delete("status", Status.Alive);

// delete all persons
personRepository.deleteAll();

// delete by id
boolean deleted = personRepository.deleteById(personId);

// set the name of all living persons to 'Mortal'
long updated = personRepository.update("name", "Mortal").where("status", Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p>すべての <code>list</code> メソッドは、同等の <code>stream</code> バージョンがあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stream&lt;Person&gt; persons = personRepository.streamAll();
List&lt;String&gt; namesButEmmanuels = persons
    .map(p -&gt; p.name.toLowerCase() )
    .filter( n -&gt; ! "emmanuel".equals(n) )
    .collect(Collectors.toList());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>persistOrUpdate()</code> メソッドは、データベース内のエンティティを永続化または更新するために存在し、MongoDB の _upsert_機能を使用して単一のクエリでそれを行います。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
残りのドキュメントでは、アクティブレコードパターンに基づく使用法のみを示していますが、リポジトリパターンでも実行できることを覚えておいてください。リポジトリパターンの例は簡潔にするために省略しています。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="writing-a-jax-rs-resource"><a class="anchor" href="#writing-a-jax-rs-resource"></a>Writing a JAX-RS resource</h2>
<div class="sectionbody">
<div class="paragraph">
<p>まず、JAX-RSエンドポイントを有効にするために、RESTEasyのエクステンションの1つを含めます。例えば、JAX-RSとJSONのサポートのために、 <code>io.quarkus:quarkus-resteasy-reactive-jackson</code> の依存関係を追加します。</p>
</div>
<div class="paragraph">
<p>そして、次のようなリソースを作成することで、Personエンティティの作成/読み取り/更新/削除が可能になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/persons")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class PersonResource {

    @GET
    public List&lt;Person&gt; list() {
        return Person.listAll();
    }

    @GET
    @Path("/{id}")
    public Person get(String id) {
        return Person.findById(new ObjectId(id));
    }

    @POST
    public Response create(Person person) {
        person.persist();
        return Response.created(URI.create("/persons/" + person.id)).build();
    }

    @PUT
    @Path("/{id}")
    public void update(String id, Person person) {
        person.update();
    }

    @DELETE
    @Path("/{id}")
    public void delete(String id) {
        Person person = Person.findById(new ObjectId(id));
        if(person == null) {
            throw new NotFoundException();
        }
        person.delete();
    }

    @GET
    @Path("/search/{name}")
    public Person search(String name) {
        return Person.findByName(name);
    }

    @GET
    @Path("/count")
    public Long count() {
        return Person.count();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="アドバンスドクエリー"><a class="anchor" href="#アドバンスドクエリー"></a>アドバンスドクエリー</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ページング"><a class="anchor" href="#ページング"></a>ページング</h3>
<div class="paragraph">
<p><code>list</code> および <code>stream</code> メソッドは、コレクションに含まれるデータセットが十分に小さい場合にのみ使用してください。より大きなデータセットの場合は、同等の <code>find</code> メソッドを使用して、ページングが可能な <code>PanacheQuery</code> を返すことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// create a query for all living persons
PanacheQuery&lt;Person&gt; livingPersons = Person.find("status", Status.Alive);

// make it use pages of 25 entries at a time
livingPersons.page(Page.ofSize(25));

// get the first page
List&lt;Person&gt; firstPage = livingPersons.list();

// get the second page
List&lt;Person&gt; secondPage = livingPersons.nextPage().list();

// get page 7
List&lt;Person&gt; page7 = livingPersons.page(Page.of(7, 25)).list();

// get the number of pages
int numberOfPages = livingPersons.pageCount();

// get the total number of entities returned by this query without paging
int count = livingPersons.count();

// and you can chain methods of course
return Person.find("status", Status.Alive)
    .page(Page.ofSize(25))
    .nextPage()
    .stream()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PanacheQuery</code> 型には、ページングやリターンストリームを処理するための他の多くのメソッドがあります。</p>
</div>
</div>
<div class="sect2">
<h3 id="ページではなく範囲を使用する"><a class="anchor" href="#ページではなく範囲を使用する"></a>ページではなく範囲を使用する</h3>
<div class="paragraph">
<p><code>PanacheQuery</code> では、範囲ベースのクエリも可能です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// create a query for all living persons
PanacheQuery&lt;Person&gt; livingPersons = Person.find("status", Status.Alive);

// make it use a range: start at index 0 until index 24 (inclusive).
livingPersons.range(0, 24);

// get the range
List&lt;Person&gt; firstRange = livingPersons.list();

// to get the next range, you need to call range again
List&lt;Person&gt; secondRange = livingPersons.range(25, 49).list();</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>範囲とページを混在させることはできません。範囲を使用した場合、現在のページを持っていることに依存するすべてのメソッドは <code>UnsupportedOperationException</code> をスローします。<code>page(Page)</code> もしくは <code>page(int, int)</code> を使用してページングに切り換えられます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ソート"><a class="anchor" href="#ソート"></a>ソート</h3>
<div class="paragraph">
<p>クエリ文字列を受け付けるすべてのメソッドは、オプションで <code>Sort</code> パラメータも受け付けるので、ソートを抽象化することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Person&gt; persons = Person.list(Sort.by("name").and("birth"));

// and with more restrictions
List&lt;Person&gt; persons = Person.list("status", Sort.by("name").and("birth"), Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Sort</code> クラスには、列を追加したり、ソート方向を指定したりするメソッドが豊富に用意されています。</p>
</div>
</div>
<div class="sect2">
<h3 id="シンプルなクエリ"><a class="anchor" href="#シンプルなクエリ"></a>シンプルなクエリ</h3>
<div class="paragraph">
<p>通常、MongoDB のクエリは次のような形式です。 <code>{'firstname': 'John', 'lastname':'Doe'}</code> 、これを MongoDB ネイティブクエリと呼んでいます。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm#BNBTG">JPQL</a>(または <a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql">HQL</a>)のサブセットとも言える *PanacheQL*というものもサポートしており、簡単にクエリを表現することができます。MongoDB with Panacheは、それをMongoDBのネイティブクエリにマッピングします。</p>
</div>
<div class="paragraph">
<p><code>{</code> で始まらないクエリは、PanacheQL クエリとみなします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;singlePropertyName&gt;</code> (およびシングルパラメータ) は `{'singleColumnName': '?1'}`に展開されます。</p>
</li>
<li>
<p><code>&lt;query&gt;</code> は <code>{&lt;query&gt;}</code> に展開され、PanacheQL のクエリを MongoDB のネイティブクエリ形式にマッピングします。以下の演算子をサポートしており、対応するMongoDBの演算子にマッピングされます。'and', 'or' ('and' と 'or' の混合は現在サポートされていません)、 '=', '&gt;', '&gt;=', '&lt;', '&lt;=', '!=', 'is null', 'is not null', そして MongoDB <code>$regex</code> 演算子にマッピングされる 'like' (String と JavaScript の両方のパターンをサポートしています)。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>クエリの例を紹介します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>firstname = ?1 and status = ?2</code> は `{'firstname': ?1, 'status': ?2}`にマッピングされます。</p>
</li>
<li>
<p><code>amount &gt; ?1 and firstname != ?2</code> は <code>{'amount': {'$gt': ?1}, 'firstname': {'$ne': ?2}}</code> にマッピングされます。</p>
</li>
<li>
<p><code>lastname like ?1</code> は <code>{'lastname': {'$regex': ?1}}</code> にマッピングされます。これは <a href="https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex">MongoDB の正規表現</a>をサポートするもので、SQL のようなパターンではないことに注意しましょう。</p>
</li>
<li>
<p><code>lastname is not null</code> は <code>{'lastname':{'$exists': true}}</code> にマッピングされます。</p>
</li>
<li>
<p><code>status in ?1</code> は `{'status':{$in: [?1]}}`にマッピングされます。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
MongoDBのクエリは、有効なJSONドキュメントでなければなりません。同じフィールドをクエリ内で複数回使用することは、無効なJSONを生成することになるため、PanacheQLでは許可されません ( <a href="https://github.com/quarkusio/quarkus/issues/12086">githubのこの問題</a>を参照)。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>また、基本的な日付型の変換も行います。 <code>Date</code>, <code>LocalDate</code>, <code>LocalDateTime</code> もしくは <code>Instant</code> 型のすべてのフィールドは、 <code>ISODate</code> 型 (UTC datetime) を使って <a href="https://docs.mongodb.com/manual/reference/bson-types/#date">BSON Date</a>にマッピングされます。MongoDB POJO コーデックは <code>ZonedDateTime</code> と <code>OffsetDateTime</code> をサポートしていないので、使う前に変換しておく必要があります。</p>
</div>
<div class="paragraph">
<p>MongoDB with Panacheは、 <code>Document</code> クエリを提供することでMongoDBの拡張クエリもサポートしています。これはfind/list/stream/count/deleteメソッドでサポートされています。</p>
</div>
<div class="paragraph">
<p>MongoDB with Panache offers operations to update multiple documents based on an update document and a query : <code>Person.update("foo = ?1, bar = ?2", fooName, barName).where("name = ?1", name)</code>.</p>
</div>
<div class="paragraph">
<p>これらの操作では、クエリを表現するのと同じように、更新文書を表現することができます。以下に例を示します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;singlePropertyName&gt;</code> (およびシングルパラメーター)で、更新ドキュメント <code>{'$set' : {'singleColumnName': '?1'}}</code> に展開します。</p>
</li>
<li>
<p><code>firstname = ?1, status = ?2</code> は更新ドキュメント <code>{'$set' : {'firstname': ?1, 'status': ?2}}</code> にマッピングされます。</p>
</li>
<li>
<p><code>firstname = :firstname, status = :status</code> は更新ドキュメント `{'$set' : {'firstname': :firstname, 'status': :status}}`にマッピングされます。</p>
</li>
<li>
<p><code>{'firstname' : ?1, 'status' : ?2}</code> は更新ドキュメント <code>{'$set' : {'firstname': ?1, 'status': ?2}}</code> にマッピングされます。</p>
</li>
<li>
<p><code>{'firstname' : firstname, 'status' : :status}</code> <code>は、アップデートドキュメントに `{'$set' : {'firstname': :firstname, 'status': :status}}</code> マッピングされます。</p>
</li>
<li>
<p><code>{'$inc': {'cpt': ?1}}</code> はそのまま使用します。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="クエリパラメーター"><a class="anchor" href="#クエリパラメーター"></a>クエリパラメーター</h3>
<div class="paragraph">
<p>ネイティブクエリとPanacheQLクエリの両方で、以下のようにインデックス（1ベース）ごとにクエリパラメータを渡すことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive);
Person.find("{'name': ?1, 'status': ?2}", "Loïc", Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p>または、 <code>Map</code> を使った名前で、</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
params.put("name", "Loïc");
params.put("status", Status.Alive);
Person.find("name = :name and status = :status", params);
Person.find("{'name': :name, 'status', :status}", params);</code></pre>
</div>
</div>
<div class="paragraph">
<p>または便利なクラスである <code>Parameters</code> をそのまま使用するか、 <code>Map</code> を構築する。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// generate a Map
Person.find("name = :name and status = :status",
         Parameters.with("name", "Loïc").and("status", Status.Alive).map());

// use it as-is
Person.find("{'name': :name, 'status': :status}",
         Parameters.with("name", "Loïc").and("status", Status.Alive));</code></pre>
</div>
</div>
<div class="paragraph">
<p>すべてのクエリ操作は、インデックス( <code>Object…​</code>)または名前( <code>Map&lt;String,Object&gt;</code> または <code>Parameters</code>)でパラメータを渡すことができます。</p>
</div>
<div class="paragraph">
<p>クエリパラメータを使う場合、PanacheQLのクエリはObjectパラメータ名を参照しますが、ネイティブのクエリはMongoDBのフィールド名を参照するので注意が必要です。</p>
</div>
<div class="paragraph">
<p>次のようなエンティティを想像してみてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person extends PanacheMongoEntity {
    @BsonProperty("lastname")
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByNameWithPanacheQLQuery(String name){
        return find("name", name).firstResult();
    }

    public static Person findByNameWithNativeQuery(String name){
        return find("{'lastname': ?1}", name).firstResult();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>findByNameWithPanacheQLQuery()</code> と <code>findByNameWithNativeQuery()</code> はどちらも同じ結果を返しますが、PanacheQL で書かれたクエリはエンティティのフィールド名 <code>name</code> を使用し、ネイティブクエリは MongoDB のフィールド名 <code>lastname</code> を使用します。</p>
</div>
</div>
<div class="sect2">
<h3 id="クエリの投影"><a class="anchor" href="#クエリの投影"></a>クエリの投影</h3>
<div class="paragraph">
<p>クエリの投影は、 <code>find()</code> のメソッドが返す <code>PanacheQuery</code> オブジェクトに対して <code>project(Class)</code> のメソッドで行うことができます。</p>
</div>
<div class="paragraph">
<p>これを使って、データベースから返されるフィールドを制限することができます。IDフィールドは常に返されますが、これをプロジェクションクラス内に含めることは必須ではありません。</p>
</div>
<div class="paragraph">
<p>そのためには、投影されたフィールドのみを含むクラス（POJO）を作成する必要があります。このPOJOには、 <code>@ProjectionFor(Entity.class)</code> でアノテーションを付ける必要があります。 <code>Entity</code> はエンティティ・クラスの名前です。プロジェクション・クラスのフィールド名（ゲッター）は、データベースから読み込まれるプロパティを制限するために使用されます。</p>
</div>
<div class="paragraph">
<p>投影は、PanacheQLとネイティブクエリの両方で行うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.mongodb.panache.common.ProjectionFor;
import org.bson.codecs.pojo.annotations.BsonProperty;

// using public fields
@ProjectionFor(Person.class)
public class PersonName {
    public String name;
}

// using getters
@ProjectionFor(Person.class)
public class PersonNameWithGetter {
    private String name;

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}

// only 'name' will be loaded from the database
PanacheQuery&lt;PersonName&gt; shortQuery = Person.find("status ", Status.Alive).project(PersonName.class);
PanacheQuery&lt;PersonName&gt; query = Person.find("'status': ?1", Status.Alive).project(PersonNameWithGetter.class);
PanacheQuery&lt;PersonName&gt; nativeQuery = Person.find("{'status': 'ALIVE'}", Status.Alive).project(PersonName.class);</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
エンティティクラスのマッピングが使用されるため、カスタムカラムマッピングを定義するために <code>@BsonProperty</code> を使用する必要はありません。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
投影クラスが他のクラスを継承している場合があります。この場合、親クラスも <code>@ProjectionFor</code> アノテーションを持つ必要があります。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="クエリのデバッグ"><a class="anchor" href="#クエリのデバッグ"></a>クエリのデバッグ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDB with Panacheではシンプルなクエリを書くことができますが、生成されたネイティブクエリをログに残しておくと、デバッグの際に便利なことがあります。</p>
</div>
<div class="paragraph">
<p>これは、 <code>application.properties</code> の中で以下のログカテゴリーを DEBUG に設定することで実現できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.log.category."io.quarkus.mongodb.panache.runtime".level=DEBUG</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pojocodecprovider-オブジェクトからbsonドキュメントへの変換を簡単に行うことができます"><a class="anchor" href="#pojocodecprovider-オブジェクトからbsonドキュメントへの変換を簡単に行うことができます"></a>PojoCodecProvider: オブジェクトからBSONドキュメントへの変換を簡単に行うことができます。</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDB with Panacheは、<a href="https://mongodb.github.io/mongo-java-driver/4.2/pojos/#pojo-support">automatic POJO support</a>の <a href="https://mongodb.github.io/mongo-java-driver/4.2/bson/pojos">PojoCodecProvider</a>を使用して、オブジェクトをBSONドキュメントに自動変換します。</p>
</div>
<div class="paragraph">
<p><code>org.bson.codecs.configuration.CodecConfigurationException</code> の例外が発生した場合、コーデックがオブジェクトを自動的に変換できないことを意味します。このコーデックは、Java Bean 標準に準拠しているため、パブリックフィールドまたはゲッター/セッターを使用する POJO を正常に変換します。 <code>@BsonIgnore</code> を使用して、フィールドまたはゲッター/セッターをコーデックで無視することができます。</p>
</div>
<div class="paragraph">
<p>クラスがこれらの規則に従わない場合（例えば、 <code>get</code> で始まるがセッターではないメソッドを含む場合）、そのクラスにカスタムコーデックを提供することができます。あなたのカスタム・コーデックは、自動的に検出され、コーデック・レジストリに登録されます。詳しくは、 <a href="mongodb.html#simplifying-mongodb-client-usage-using-bson-codec">BSONコーデックの使用</a>をご覧ください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="トランザクション"><a class="anchor" href="#トランザクション"></a>トランザクション</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDBは、バージョン4.0からACIDトランザクションを提供しています。</p>
</div>
<div class="paragraph">
<p>MongoDB with Panacheでこれらを使うには、トランザクションを開始するメソッドに <code>@Transactional</code> アノテーションを付ける必要があります。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
MongoDB with Panache内部のトランザクションサポートはまだ実験的なものです。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="カスタムid"><a class="anchor" href="#カスタムid"></a>カスタムID</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ID はしばしば微妙な問題です。MongoDBでは、IDは通常、 <code>ObjectId</code> 型でデータベースによって自動生成されます。MongoDB with Panacheでは、IDは <code>org.bson.types.ObjectId</code> 型の <code>id</code> というフィールドで定義されていますが、もしカスタマイズしたいのであれば、私たちがサポートします。</p>
</div>
<div class="paragraph">
<p><code>PanacheMongoEntity</code> の代わりに <code>PanacheMongoEntityBase</code> を拡張することで、独自のID戦略を指定することができます。そして、 <code>@BsonId</code> でアノテーションを付けて、好きなIDをパブリック・フィールドとして宣言します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MongoEntity
public class Person extends PanacheMongoEntityBase {

    @BsonId
    public Integer myId;

    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>リポジトリを使用している場合は、 <code>PanacheMongoRepository</code> の代わりに <code>PanacheMongoRepositoryBase</code> を拡張し、ID 型を追加の型パラメータとして指定することになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class PersonRepository implements PanacheMongoRepositoryBase&lt;Person,Integer&gt; {
    //...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ObjectId</code> を使う場合は、MongoDB が自動的に値を提供してくれますが、カスタムフィールド型を使う場合は、自分で値を提供する必要があります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ObjectId</code> は、REST サービスでその値を公開したい場合、使用するのが難しいことがあります。そこで、RESTEasy Jackson extensionまたはRESTEasy JSON-B extensionに依存するプロジェクトであれば自動的に登録される、 <code>String</code> としてシリアライズ/デシリアライズするJacksonおよびJSON-Bプロバイダを作成しました。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>標準の <code>ObjectId</code> ID型を使用する場合、識別子がパスパラメータから来ているときは、新しい <code>ObjectId</code> を作成してエンティティを取得することを忘れないでください。例えば以下のように行います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GET
@Path("/{id}")
public Person findById(String id) {
    return Person.findById(new ObjectId(id));
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="working-with-kotlin-data-classes"><a class="anchor" href="#working-with-kotlin-data-classes"></a>Working with Kotlin Data classes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kotlinのデータクラスは、データキャリアクラスを定義する非常に便利な方法であり、エンティティクラスを定義するのに適しています。</p>
</div>
<div class="paragraph">
<p>しかし、このクラスの型はいくつかの制限があります。また、生成時に初期化される全てのフィールドは nullable としてマークされ、生成されたコンストラクタは、データクラスのすべてのフィールドをパラメータとして持つ必要があります。</p>
</div>
<div class="paragraph">
<p>MongoDB with Panache は <a href="https://mongodb.github.io/mongo-java-driver/4.2/bson/pojos">PojoCodecProvider</a> を使います。これは MongoDB のコーデックで、パラメータなしのコンストラクタの存在を義務付けています。</p>
</div>
<div class="paragraph">
<p>そのため、データクラスをエンティティクラスとして使用したい場合は、Kotlinに空のコンストラクタを生成させる方法が必要です。そのためには、クラスのすべてのフィールドにデフォルト値を用意する必要があります。Kotlinのドキュメントの次の文章で説明しています。</p>
</div>
<div class="paragraph">
<p><em>JVMでは、生成されたクラスがパラメータレス・コンストラクタを持つ必要がある場合、すべてのプロパティのデフォルト値を指定する必要があります（「コンストラクタ」を参照）。</em></p>
</div>
<div class="paragraph">
<p>何らかの理由で前述の解決策が受け入れられないと判断された場合、代替手段があります。</p>
</div>
<div class="paragraph">
<p>まず、BSON Codecを作成すると、Quarkusに自動的に登録され、 <code>PojoCodecProvider</code> の代わりに使用されます。ドキュメントのこの部分を参照してください。 <a href="mongodb.html#simplifying-mongodb-client-usage-using-bson-codec">BSONコーデックの使用</a></p>
</div>
<div class="paragraph">
<p>もうひとつの方法は、 <code>@BsonCreator</code> アノテーションを使用して、 <code>PojoCodecProvider</code> に Kotlin データクラスのデフォルトコンストラクタを使用するように指示することです。この場合、すべてのコンストラクタパラメータは <code>@BsonProperty</code> でアノテーションする必要があります。「 <a href="https://mongodb.github.io/mongo-java-driver/4.2/bson/pojos/#supporting-pojos-without-no-args-constructors">Supporting pojos without no args constru</a>ctor」を参照してください。</p>
</div>
<div class="paragraph">
<p>これは、エンティティが <code>PanacheMongoEntity</code> ではなく <code>PanacheMongoEntityBase</code> を拡張している場合にのみ機能します。なぜなら、ID フィールドもコンストラクタに含める必要があるからです。</p>
</div>
<div class="paragraph">
<p>Kotlinのデータクラスとして定義された <code>Person</code> クラスの例は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class Person @BsonCreator constructor (
    @BsonId var id: ObjectId,
    @BsonProperty("name") var name: String,
    @BsonProperty("birth") var birth: LocalDate,
    @BsonProperty("status") var status: Status
): PanacheMongoEntityBase()</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ここでは、 <code>var</code> を使用していますが、 <code>val</code> も使用できることに注意してください。</p>
</div>
<div class="paragraph">
<p>簡潔にするために <code>@BsonProperty("_id")</code> の代わりに <code>@BsonId</code> のアノテーションを使用していますが、どちらを使用しても構いません。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後の方法は、 <a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin">no-arg</a>compiler plugin を使うことです。このプラグインにはアノテーションのリストが設定されており、最終的にはアノテーションが設定されている各クラスのno-argsコンストラクタが生成されます。</p>
</div>
<div class="paragraph">
<p>MongoDB with Panache では、データクラスに <code>@MongoEntity</code> アノテーションを使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@MongoEntity
data class Person (
    var name: String,
    var birth: LocalDate,
    var status: Status
): PanacheMongoEntity()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive"><a class="anchor" href="#reactive"></a>リアクティブエンティティとレポジトリー</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDB with Panacheでは、エンティティとリポジトリの両方でリアクティブスタイルの実装を使うことができます。そのためには、エンティティを定義するときには <code>ReactivePanacheMongoEntity</code> または <code>ReactivePanacheMongoEntityBase</code> を、リポジトリを定義するときには <code>ReactivePanacheMongoRepository</code> または <code>ReactivePanacheMongoRepositoryBase</code> を、それぞれ Reactive バリアントとして使用する必要があります。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Mutiny</div>
<div class="paragraph">
<p>MongoDB with PanacheのリアクティブAPIは、Mutinyのリアクティブ型を使用しています。Mutinyに慣れていない方は、 <a href="mutiny-primer.html">Mutiny - an intuitive reactive programming library</a>をご覧ください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Person</code> クラスのリアクティブ・バリアントは以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ReactivePerson extends ReactivePanacheMongoEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    // return name as uppercase in the model
    public String getName(){
        return name.toUpperCase();
    }

    // store all names in lowercase in the DB
    public void setName(String name){
        this.name = name.toLowerCase();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>bsonアノテーション、カスタムID、PanacheQLなど、 リアクティブ バリアント内で <em>命令型</em> のバリアントと同じ機能を利用できますが、エンティティやリポジトリのメソッドはすべてリアクティブ型を返します。</p>
</div>
<div class="paragraph">
<p>リアクティブ バリアントを持つ命令型の例から、同等のメソッドを見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// creating a person
ReactivePerson person = new ReactivePerson();
person.name = "Loïc";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;

// persist it: if you keep the default ObjectId ID field, it will be populated by the MongoDB driver,
// and accessible when uni1 will be resolved
Uni&lt;ReactivePerson&gt; uni1 = person.persist();

person.status = Status.Dead;

// Your must call update() in order to send your entity modifications to MongoDB
Uni&lt;ReactivePerson&gt; uni2 = person.update();

// delete it
Uni&lt;Void&gt; uni3 = person.delete();

// getting a list of all persons
Uni&lt;List&lt;ReactivePerson&gt;&gt; allPersons = ReactivePerson.listAll();

// finding a specific person by ID
// here we build a new ObjectId but you can also retrieve it from the existing entity after being persisted
ObjectId personId = new ObjectId(idAsString);
Uni&lt;ReactivePerson&gt; personById = ReactivePerson.findById(personId);

// finding a specific person by ID via an Optional
Uni&lt;Optional&lt;ReactivePerson&gt;&gt; optional = ReactivePerson.findByIdOptional(personId);
personById = optional.map(o -&gt; o.orElseThrow(() -&gt; new NotFoundException()));

// finding all living persons
Uni&lt;List&lt;ReactivePerson&gt;&gt; livingPersons = ReactivePerson.list("status", Status.Alive);

// counting all persons
Uni&lt;Long&gt; countAll = ReactivePerson.count();

// counting all living persons
Uni&lt;Long&gt; countAlive = ReactivePerson.count("status", Status.Alive);

// delete all living persons
Uni&lt;Long&gt;  deleteCount = ReactivePerson.delete("status", Status.Alive);

// delete all persons
deleteCount = ReactivePerson.deleteAll();

// delete by id
Uni&lt;Boolean&gt; deleted = ReactivePerson.deleteById(personId);

// set the name of all living persons to 'Mortal'
Uni&lt;Long&gt; updated = ReactivePerson.update("name", "Mortal").where("status", Status.Alive);</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
RESTEasyでMongoDB with Panacheを併用している場合、 <code>quarkus-resteasy-mutiny</code> エクステンションを含めれば、JAX-RSリソースエンドポイント内でリアクティブ型を直接返すことができます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>リアクティブ型に対しても同様の問い合わせ機能がありますが、 <code>stream()</code> メソッドの動作は異なります。 <code>Stream</code> の代わりに <code>Multi</code> （リアクティブストリーム <code>Publisher</code> を実装したもの）を返します。</p>
</div>
<div class="paragraph">
<p>これにより、より高度なリアクティブなユースケースが可能となり、例えば、RESTEasyを介してSSE（Server-Sent Event）を送信するために使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.jboss.resteasy.reactive.RestStreamElementType;
import org.reactivestreams.Publisher;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

@GET
@Path("/stream")
@Produces(MediaType.SERVER_SENT_EVENTS)
@RestStreamElementType(MediaType.APPLICATION_JSON)
public Multi&lt;ReactivePerson&gt; streamPersons() {
    return ReactivePerson.streamAll();
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@SseElementType(MediaType.APPLICATION_JSON)</code> がRESTEasyにJSONでオブジェクトをシリアライズするように指示します。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
トランザクションは、Reactive エンティティおよびRepositoryではサポートされていません。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="モック"><a class="anchor" href="#モック"></a>モック</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="アクティブレコードパターンの使用"><a class="anchor" href="#アクティブレコードパターンの使用"></a>アクティブ・レコード・パターンの使用</h3>
<div class="paragraph">
<p>active-recordパターンを使用している場合、Mockitoはスタティック・メソッドのモックをサポートしていないため、直接使用することはできませんが、 <code>quarkus-panache-mock</code> モジュールを使用することで、Mockitoを使用して、あなた自身のメソッドを含む、提供されたすべてのスタティック・メソッドをモックすることができます。</p>
</div>
<div class="paragraph">
<p>この依存関係を <code>pom.xml</code> に追加してください。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-panache-mock&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-panache-mock")</code></pre>
</div>
</div>
<div class="paragraph">
<p>このシンプルなエンティティがある場合に</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person extends PanacheMongoEntity {

    public String name;

    public static List&lt;Person&gt; findOrdered() {
        return findAll(Sort.by("lastname", "firstname")).list();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>モッキングテストはこのように書くことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class PanacheFunctionalityTest {

    @Test
    public void testPanacheMocking() {
        PanacheMock.mock(Person.class);

        // Mocked classes always return a default value
        Assertions.assertEquals(0, Person.count());

        // Now let's specify the return value
        Mockito.when(Person.count()).thenReturn(23L);
        Assertions.assertEquals(23, Person.count());

        // Now let's change the return value
        Mockito.when(Person.count()).thenReturn(42L);
        Assertions.assertEquals(42, Person.count());

        // Now let's call the original method
        Mockito.when(Person.count()).thenCallRealMethod();
        Assertions.assertEquals(0, Person.count());

        // Check that we called it 4 times
        PanacheMock.verify(Person.class, Mockito.times(4)).count();<i class="conum" data-value="1"></i><b>(1)</b>

        // Mock only with specific parameters
        Person p = new Person();
        Mockito.when(Person.findById(12L)).thenReturn(p);
        Assertions.assertSame(p, Person.findById(12L));
        Assertions.assertNull(Person.findById(42L));

        // Mock throwing
        Mockito.when(Person.findById(12L)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -&gt; Person.findById(12L));

        // We can even mock your custom methods
        Mockito.when(Person.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(Person.findOrdered().isEmpty());

        PanacheMock.verify(Person.class).findOrdered();
        PanacheMock.verify(Person.class, Mockito.atLeastOnce()).findById(Mockito.any());
        PanacheMock.verifyNoMoreInteractions(Person.class);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>verify</code> のメソッドを <code>Mockito</code> ではなく <code>PanacheMock</code> で呼び出すようにしてください。そうしないと、どのモックオブジェクトを渡せばいいのかわかりません。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="リポジトリパターンの使用"><a class="anchor" href="#リポジトリパターンの使用"></a>リポジトリパターンの使用</h3>
<div class="paragraph">
<p>リポジトリパターンを使用している場合は、 <code>quarkus-junit5-mockito</code> モジュールを使用して、Mockito を直接使用することができます。これにより、ビーンのモッキングが非常に簡単になります。</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit5-mockito&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">testImplementation("io.quarkus:quarkus-junit5-mockito")</code></pre>
</div>
</div>
<div class="paragraph">
<p>このシンプルなエンティティがある場合に</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Person {

    @BsonId
    public Long id;

    public String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そしてこのリポジトリ。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class PersonRepository implements PanacheMongoRepository&lt;Person&gt; {
    public List&lt;Person&gt; findOrdered() {
        return findAll(Sort.by("lastname", "firstname")).list();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>モッキングテストはこのように書くことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class PanacheFunctionalityTest {
    @InjectMock
    PersonRepository personRepository;

    @Test
    public void testPanacheRepositoryMocking() throws Throwable {
        // Mocked classes always return a default value
        Assertions.assertEquals(0, personRepository.count());

        // Now let's specify the return value
        Mockito.when(personRepository.count()).thenReturn(23L);
        Assertions.assertEquals(23, personRepository.count());

        // Now let's change the return value
        Mockito.when(personRepository.count()).thenReturn(42L);
        Assertions.assertEquals(42, personRepository.count());

        // Now let's call the original method
        Mockito.when(personRepository.count()).thenCallRealMethod();
        Assertions.assertEquals(0, personRepository.count());

        // Check that we called it 4 times
        Mockito.verify(personRepository, Mockito.times(4)).count();

        // Mock only with specific parameters
        Person p = new Person();
        Mockito.when(personRepository.findById(12L)).thenReturn(p);
        Assertions.assertSame(p, personRepository.findById(12L));
        Assertions.assertNull(personRepository.findById(42L));

        // Mock throwing
        Mockito.when(personRepository.findById(12L)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -&gt; personRepository.findById(12L));

        Mockito.when(personRepository.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(personRepository.findOrdered().isEmpty());

        // We can even mock your custom methods
        Mockito.verify(personRepository).findOrdered();
        Mockito.verify(personRepository, Mockito.atLeastOnce()).findById(Mockito.any());
        Mockito.verifyNoMoreInteractions(personRepository);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-and-why-we-simplify-mongodb-api"><a class="anchor" href="#how-and-why-we-simplify-mongodb-api"></a>How and why we simplify MongoDB API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDBのエンティティを書くときには、以下のように、ユーザーが不本意ながら慣れてしまっている厄介なことがたくさんあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IDロジックの重複:ほとんどのエンティティにはIDが必要ですが、モデルとはあまり関係がないため、ほとんどの人はIDの設定方法を気にしません。</p>
</li>
<li>
<p>Dumb getters and setters: since Java lacks support for properties in the language, we have to create fields, then generate getters and setters for those fields, even if they don&#8217;t actually do anything more than read/write the fields.</p>
</li>
<li>
<p>従来のEEパターンでは、エンティティの定義（モデル）とそれに対する操作（DAOやリポジトリ）を分けることが推奨されていましたが、実際には、状態とその操作を不自然な形で分ける必要があります。状態とその操作が1つのクラスに存在するオブジェクト指向アーキテクチャでは通常そのようなことは行いません。さらに、エンティティごとに2つのクラスを必要とし、エンティティの操作を行う必要があるDAOやリポジトリをインジェクションする必要があります。これにより、編集フローが壊れ、インジェクションポイントを設定するために書いているコードから抜け出してから、それを使用するために戻ってこなければなりません。</p>
</li>
<li>
<p>MongoDBのクエリは非常に強力ですが、一般的な操作では冗長すぎて、すべてのパーツが必要ではない場合でもクエリを書かなければなりません。</p>
</li>
<li>
<p>MongoDBのクエリはJSONベースなので、文字列の操作や <code>Document</code> 型を使う必要があり、多くのボイラープレートコードが必要になります。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Panacheでは、これらの問題に対して、定見に基づいたアプローチをとりました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>エンティティは <code>PanacheMongoEntity</code> を拡張するようにしてください：自動生成されるIDフィールドがあります。カスタムのID戦略が必要な場合は、代わりに <code>PanacheMongoEntityBase</code> を拡張して、IDを自分で処理することができます。</p>
</li>
<li>
<p>パブリックフィールドを使ってください。無駄なゲッターとセッターを無くせます。フードの下では、不足しているすべてのゲッターとセッターを生成し、これらのフィールドへのすべてのアクセスを、アクセサ・メソッドを使用するように書き換えます。この方法では、必要なときに <em>便利な</em> アクセサを書くことができ、エンティティ・ユーザーがフィールド・アクセスを使用していても、それが使用されます。</p>
</li>
<li>
<p>アクティブレコードパターンの使用: アクティブレコードパターンでは、すべてのエンティティロジックをエンティティクラスのスタティックメソッドに置き、DAOを作りません。エンティティスーパークラスには、非常に便利なスタティックメソッドがたくさん用意されていますし、エンティティクラスに独自のメソッドを追加することもできます。 <code>Person</code> ユーザーは、 <code>Person</code> と入力するだけで、すべての操作を一か所で完了させることができます。</p>
</li>
<li>
<p>必要のない部分を書かないようにしましょう: <code>Person.find("order by name")</code> や <code>Person.find("name = ?1 and status = ?2", "Loïc", Status.Alive)</code> 、さらには <code>Person.find("name", "Loïc")</code> のように書きましょう。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上となります: Panacheを使えば、MongoDBがこれほどまでに整然としたものになるのです。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="外部プロジェクトや-jar-でエンティティーを定義する"><a class="anchor" href="#外部プロジェクトや-jar-でエンティティーを定義する"></a>外部プロジェクトや jar でエンティティーを定義する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDB with Panacheは、エンティティに対してコンパイル時にバイトコードを強化します。</p>
</div>
<div class="paragraph">
<p>これは、マーカーファイル <code>META-INF/panache-archive.marker</code> の存在によって、Panache エンティティを持つアーカイブ（および Panache エンティティのコンシューマー）を識別しようとするものです。Panacheには、Panacheに（間接的にでも）依存しているアーカイブでこのファイルを自動的に作成するアノテーションプロセッサが含まれています。アノテーションプロセッサを無効にしている場合、場合によってはこのファイルを手動で作成する必要があります。</p>
</div>
</div>
</div>
    </div>
  </div>
</div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus はオープンです。このプロジェクトの全ての依存関係は<a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a>または互換性のあるライセンスの元で利用出来ます。<br /><br />このウェブサイトは <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a> で構築されており、<a href='https://pages.github.com/' target='_blank'>Github Pages</a>にホストされており、完全にオープンソースです。改善したい場合、 <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>ウェブサイトをフォークし</a>、修正してみせてください。</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
            <li><a href="/">ホーム</a></li>
          
            <li><a href="/about">Quarkusについて</a></li>
          
            <li><a href="/blog">ブログ</a></li>
          
            <li><a href="/insights">ポッドキャスト</a></li>
          
            <li><a href="/events">イベント</a></li>
          
            <li><a href="/newsletter">ニュースレター</a></li>
          
            <li><a href="/publications">出版</a></li>
          
            <li><a href="/awards">受賞</a></li>
          
            <li><a href="/security">セキュリティポリシー</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォロー</span>
        <ul class="footer-links">
          
            <li><a href="https://twitter.com/quarkusio">Twitter</a></li>
          
            <li><a href="https://www.facebook.com/quarkusio">Facebook</a></li>
          
            <li><a href="https://www.linkedin.com/company/quarkusio/">Linkedin</a></li>
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg">Youtube</a></li>
          
            <li><a href="https://github.com/quarkusio">GitHub</a></li>
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
            <li><a href="/support">サポート</a></li>
          
            <li><a href="/guides">ガイド</a></li>
          
            <li><a href="/faq">FAQ</a></li>
          
            <li><a href="/get-started">入門</a></li>
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus">Stack Overflow</a></li>
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions">ディスカッション</a></li>
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev">開発メーリングリスト</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Languages</span>
        <ul class="footer-links">
          
            <li><a href="https://quarkus.io/">English</a></li>
          
            <li><a href="https://ja.quarkus.io/">Japanese</a></li>
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています：</span>
        <ul class="footer-links">
          
            <li><a href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a href="https://code.quarkus.io/" target="_blank">等々...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a> | <a href="https://www.redhat.com/en/about/privacy-policy">Privacy Policy</a>
    </span>
    <span class="redhat">
      Sponsored by
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/search-filter.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
</body>

</html>
