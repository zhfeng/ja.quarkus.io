<!DOCTYPE html>
<html>





<head>
  <title>Quarkus - Writing Your Own Extension - main</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src https://dpm.demdex.net; script-src 'self' 'unsafe-eval' 'sha256-ANpuoVzuSex6VhqpYgsG25OHWVA1I+F6aGU04LoI+5s=' 'sha256-ipy9P/3rZZW06mTLAR0EnXvxSNcnfSDPLDuh3kzbB1w=' js.bizographics.com https://www.redhat.com https://static.redhat.com assets.adobedtm.com jsonip.com https://ajax.googleapis.com https://www.googletagmanager.com https://www.google-analytics.com https://use.fontawesome.com https://app.mailjet.com http://www.youtube.com http://www.googleadservices.com https://googleads.g.doubleclick.net https://dpm.demdex.net https://giscus.app; style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; img-src 'self' *; media-src 'self'; frame-src https://www.googletagmanager.com https://www.youtube.com https://embed.restream.io https://app.mailjet.com https://giscus.app; base-uri 'none'; object-src 'none'; form-action 'none'; font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/version/main/guides/writing-extensions" />
  <meta property="og:title" content="Writing Your Own Extension - main" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/writing-extensions">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/goan.js" type="text/javascript"></script>
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
</head>

<body class="guides">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJWS5L"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
  <div class="container">
    <div class="logo-wrapper">
        <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
    </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="/about/">Quarkusとは <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUSとは何か?</a></li>
          <li><a href="/container-first" class="">コンテナ・ファースト</a></li>
          <li><a href="/continuum" class="">リアクティブ</a></li>
          <li><a href="/developer-joy" class="">開発者満足</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVE</a></li>
          <li><a href="/standards" class="">標準</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="/learn/">学ぶ<i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入門</a></li>
          <li><a href="/guides" class="active">ガイド</a></li>
          <li><a href="/qtips" class="">"Q" Tipsビデオ</a></li>          
          <li><a href="/books" class="">書籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="/community/">コミュニティ <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">サポート</a></li>
          <li><a href="/blog" class="">ブログ</a></li>
          <li><a href="/discussion" class="">ディスカッション</a></li>
          <li><a href="/insights" class="">ポッドキャスト</a></li>
          <li><a href="/events" class="">イベント</a></li>
          <li><a href="/newsletter" class="">ニュースレター</a></li>
          <li><a href="/publications" class="">出版物</a></li>
          <li><a href="/awards" class="">受賞</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">コーディングを開始</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/" >ENGLISH</a></li>
          <li><a href="https://ja.quarkus.io/">JAPANESE</a></li>
          </ul>
      </li>
    </ul>
  </div>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    



<div class="full-width-version-bg grey align-self">
  <div class="grid-wrapper">
    <div class="grid__item width-6-12">
      <p class="returnlink"><i class="fas fa-angle-left"></i><a href="/version/main/guides/"> Back to Guides</a></p>
    </div>
    <div class="grid__item width-6-12 align-self-center text-right hide-mobile">
      <label id="guide-version-label">Select Guide Version</label>
      <select id="guide-version-dropdown">
        
      
        
        
        
        
          
        <option value="main" selected>Main - SNAPSHOT</option>
        
        
      
        
        
        
        
          
        <option value="latest" >2.9 - Latest</option>
        
        
      
        
        
        
        
          
        <option value="2.7" >2.7</option>
        
        
      
        
        
        
        
          
        <option value="2.2" >2.2</option>
        
        
      
        
        
        
        
          
        <option value="1.11" >1.11</option>
        
        
      
    
      </select>
    </div>
  </div>
</div>

<div class="grid-wrapper guide">
  <div class="grid__item width-12-12 width-12-12-mobile">
    <h1 class="text-caps">Writing Your Own Extension </h1>
  </div>
  <div class="width-12-12">
    <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#エクステンション哲学">1. エクステンション哲学</a>
<ul class="sectlevel2">
<li><a href="#なぜエクステンションフレームワークなのか">1.1. なぜエクステンションフレームワークなのか</a></li>
<li><a href="#ランタイムワークよりもビルドタイムワーク">1.2. ランタイムワークよりもビルドタイムワーク</a></li>
<li><a href="#設定を公開する方法">1.3. 設定を公開する方法</a></li>
<li><a href="#expose-your-components-via-cdi">1.4. Expose your components via CDI</a></li>
<li><a href="#エクステンションのタイプ">1.5. エクステンションのタイプ</a></li>
</ul>
</li>
<li><a href="#技術的な側面">2. 技術的な側面</a>
<ul class="sectlevel2">
<li><a href="#bootstrap-three-phases">2.1. Three Phases of Bootstrap and Quarkus Philosophy</a></li>
<li><a href="#プロジェクトのセットアップ">2.2. プロジェクトのセットアップ</a></li>
<li><a href="#ビルドステッププロセッサー">2.3. ビルドステッププロセッサー</a></li>
<li><a href="#configuration">2.4. 設定</a></li>
<li><a href="#conditional-step-inclusion">2.5. Conditional Step Inclusion</a></li>
<li><a href="#bytecode-recording">2.6. バイトコードの記録</a></li>
<li><a href="#コンテキストと依存性インジェクション">2.7. コンテキストと依存性インジェクション</a></li>
<li><a href="#quarkus-dev-ui">2.8. Quarkus Dev UI</a></li>
<li><a href="#エクステンションで定義されたエンドポイント">2.9. エクステンションで定義されたエンドポイント</a></li>
<li><a href="#エクステンションヘルスチェック">2.10. エクステンションヘルスチェック</a></li>
<li><a href="#エクステンションメトリクス">2.11. エクステンションメトリクス</a></li>
<li><a href="#エクステンションからjson処理をカスタマイズする">2.12. エクステンションからJSON処理をカスタマイズする</a></li>
<li><a href="#integrating-with-development-mode">2.13. Integrating with Development Mode</a></li>
<li><a href="#エクステンションのテスト">2.14. エクステンションのテスト</a></li>
<li><a href="#ホットリロードのテスト">2.15. ホットリロードのテスト</a></li>
<li><a href="#ネイティブ実行可能ファイルのサポート">2.16. ネイティブ実行可能ファイルのサポート</a></li>
<li><a href="#ide-support-tips">2.17. IDE support tips</a></li>
<li><a href="#トラブルシューティング-デバッグのヒント">2.18. トラブルシューティング / デバッグのヒント</a></li>
<li><a href="#サンプルテストエクステンション">2.19. サンプルテストエクステンション</a></li>
</ul>
</li>
<li><a href="#設定リファレンスドキュメント">3. 設定リファレンスドキュメント</a>
<ul class="sectlevel2">
<li><a href="#ドキュメントの書き方">3.1. ドキュメントの書き方</a></li>
<li><a href="#セクションのドキュメントを書く">3.2. セクションのドキュメントを書く</a></li>
<li><a href="#ドキュメントの生成">3.3. ドキュメントの生成</a></li>
<li><a href="#エクステンションガイドにドキュメントを含める">3.4. エクステンションガイドにドキュメントを含める</a></li>
</ul>
</li>
<li><a href="#ecosystem-ci">4. エクステンションの継続的なテスト</a></li>
<li><a href="#エクステンションを-registry-quarkus-io-で公開">5. エクステンションを registry.quarkus.io で公開</a></li>
</ul></div>
    <div>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkusのエクステンションは、コアサービスに開発者向けの新しい動作を追加するもので、ビルド時の拡張とランタイムコンテナという2つの異なる部分から構成されています。拡張部分は、アノテーションやXML記述子の読み込みなど、すべてのメタデータ処理を担当します。この拡張フェーズの出力は、関連するランタイムサービスを直接インスタンス化するためのバイトコードとして記録されます。</p>
</div>
<div class="paragraph">
<p>これは、メタデータがビルド時に一度だけ処理されることを意味し、起動時間の節約と、処理に使用されるクラスなどがランタイムJVMにロードされない（あるいは存在しない）ため、メモリ使用量の節約の両方を実現しています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
これは詳細なドキュメントです。入門書が必要な場合は、 <a href="building-my-first-extension.html">building my first extension</a>をご覧ください。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="エクステンション哲学"><a class="anchor" href="#エクステンション哲学"></a>1. エクステンション哲学</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このセクションは作業中であり、エクステンションがどのように設計され、どのように書かれるべきかの哲学を記述します。</p>
</div>
<div class="sect2">
<h3 id="なぜエクステンションフレームワークなのか"><a class="anchor" href="#なぜエクステンションフレームワークなのか"></a>1.1. なぜエクステンションフレームワークなのか</h3>
<div class="paragraph">
<p>Quarkusの使命は、使用するライブラリを含むアプリケーション全体を、従来のアプローチよりも大幅に少ないリソースしか使用しないアーティファクトに変換することです。これらを使用して、GraalVMを使用してネイティブアプリケーションを構築することができます。これを行うためには、アプリケーションの完全な「クローズドワールド」を分析し、理解する必要があります。完全で完璧なコンテキストがなければ、達成可能なものは最高でも部分的で限定的、一般的なサポートです。Quarkusのエクステンションアプローチを使用することで、Kubernetesやクラウドプラットフォームのようなメモリフットプリントに制約のある環境にJavaアプリケーションを合わせることができます。</p>
</div>
<div class="paragraph">
<p>Quarkusエクステンションフレームワークは、GraalVMを使用していない場合（HotSpotなど）でも、リソース利用率を大幅に改善します。エクステンションが実行するアクションをリストアップしてみましょう:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ビルド時のメタデータを収集し、コードを生成</p>
<div class="ulist">
<ul>
<li>
<p>この部分はGraalVMとは何の関係もありませんが、Quarkusがフレームワークを"ビルド時" に起動する方法です。</p>
</li>
<li>
<p>エクステンションフレームワークは、必要に応じてメタデータの読み込み、クラスのスキャン、クラスの生成を容易にします。</p>
</li>
<li>
<p>拡張作業のごく一部は生成されたクラスを介して実行時に実行され、作業の大部分はビルド時に行われます (デプロイメント時と呼ばれます)</p>
</li>
</ul>
</div>
</li>
<li>
<p>アプリケーションの近い世界観に基づいて、定見に基づいた賢明なデフォルトを強制（例えば、 <code>@Entity</code> のないアプリケーションは、Hibernate ORM を起動する必要はありません）</p>
</li>
<li>
<p>エクステンションは Substrate VM のコード置換をホストし、ライブラリを GraalVM 上で実行できるようにします。</p>
<div class="ulist">
<ul>
<li>
<p>ほとんどの変更は、基礎となるライブラリがGraalVM上で動作するようにupstreamにプッシュされます。</p>
</li>
<li>
<p>すべての変更をupstreamにプッシュできるわけではないので、エクステンションは Substrate VM 置換をホスト。これはコードパッチの一形態で、ライブラリが実行できるようになっています。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Substrate VMコード置換のホストにより、アプリケーションのニーズに基づいたデッドコードの排除を支援します。</p>
<div class="ulist">
<ul>
<li>
<p>これはアプリケーションに依存しており、ライブラリ自体で共有することはできません。</p>
</li>
<li>
<p>たとえば、Quarkusは、特定の接続プールとキャッシュプロバイダだけが必要であることを知っているため、Hibernateコードを最適化します。</p>
</li>
</ul>
</div>
</li>
<li>
<p>メタデータをGraalVMに送信。例えば、リフレクションに必要なクラス</p>
<div class="ulist">
<ul>
<li>
<p>この情報はライブラリ(Hibernateなど)ごとに静的ではありませんが、フレームワークはセマンティックな知識を持っており、どのクラスがリフレクションを必要とするかを知っています(例えば@Entityクラスなど)。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ランタイムワークよりもビルドタイムワーク"><a class="anchor" href="#ランタイムワークよりもビルドタイムワーク"></a>1.2. ランタイムワークよりもビルドタイムワーク</h3>
<div class="paragraph">
<p>可能な限り、フレームワークに起動時（ランタイム）に作業をさせるのではなく、ビルド時（エクステンションのデプロイメント部分）に作業を行うことをお勧めします。そこでの作業が多いほど、そのエクステンションを使用しているQuarkusアプリケーションは小さくなり、ロードが速くなります。</p>
</div>
</div>
<div class="sect2">
<h3 id="設定を公開する方法"><a class="anchor" href="#設定を公開する方法"></a>1.3. 設定を公開する方法</h3>
<div class="paragraph">
<p>Quarkusは、最も一般的な使用法を簡略化しています。つまり、そのデフォルトは、統合されているライブラリとは異なる場合があります。</p>
</div>
<div class="paragraph">
<p>シンプルな体験を最も簡単にするために、SmallRye Configを介して <code>application.properties</code> で設定を統一します。ライブラリ固有の設定ファイルは避けるか、少なくともオプションにしてください。例えば、Hibernate ORM用の <code>persistence.xml</code> はオプションです。</p>
</div>
<div class="paragraph">
<p>エクステンションは、ライブラリの体験に焦点を当てるのではなく、Quarkusアプリケーションとして全体的に設定を見るべきです。例えば、データベースアクセスの定義が共有タスクであるように、 <code>quarkus.database.url</code> 等々がエクステンション間で共有されます（例えば <code>hibernate.</code> プロパティを使用される代わりに）。最も便利な設定オプションは、ライブラリの自然な名前空間ではなく、 <code>quarkus.[extension].</code> として公開されるべきです。あまり一般的ではないプロパティは、ライブラリの名前空間に置くことができます。</p>
</div>
<div class="paragraph">
<p>Quarkusが最適化できる閉じた世界の仮定を完全に有効にするには、ビルド時に設定された設定オプションと実行時にオーバーライド可能な設定オプションのどちらを採用するか検討するべきでしょう。もちろん、ホスト、ポート、パスワードなどのプロパティは、実行時にオーバーライド可能でなければなりません。しかし、キャッシングを有効にしたり、JDBCドライバを設定したりするような多くのプロパティは、アプリケーションの再構築を安全に要求することができます。</p>
</div>
<div class="sect3">
<h4 id="スタティック初期化設定"><a class="anchor" href="#スタティック初期化設定"></a>1.3.1. スタティック初期化設定</h4>
<div class="paragraph">
<p>エクステンションが追加のコンフィグソースを提供し、それらがスタティック初期化中に必要な場合は、それらを <code>StaticInitConfigSourceProviderBuildItem</code> に登録する必要があります。スタティック初期化での設定は、アプリケーション起動時の二重の初期化を避けるため、追加のソースをスキャンしません。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expose-your-components-via-cdi"><a class="anchor" href="#expose-your-components-via-cdi"></a>1.4. Expose your components via CDI</h3>
<div class="paragraph">
<p>CDI がコンポーネントの構成に関して中心的なプログラミングモデルであるため、フレームワークやエクステンションはそのコンポーネントを、ユーザアプリケーションが容易に消費できるBeanとして公開しなければなりません。例えば、Hibernate ORM は <code>EntityManagerFactory</code> と <code>EntityManager</code> の Bean を公開し、コネクションプールは <code>DataSource</code> のBeanを公開します。エクステンションは、ビルド時にこれらのBean定義を登録しなければなりません。</p>
</div>
<div class="sect3">
<h4 id="クラスに裏付けられたbean"><a class="anchor" href="#クラスに裏付けられたbean"></a>1.4.1. クラスに裏付けられたBean</h4>
<div class="paragraph">
<p>エクステンションは <a href="cdi-reference.html#additional_beans"><code>AdditionalBeanBuildItem</code></a> コンテナに、元のアプリケーションの一部であるかのようにクラスからBeanの定義を読み込むように指示します。</p>
</div>
<div class="listingblock">
<div class="title">登録されている Bean クラス <code>AdditionalBeanBuildItem</code></div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Singleton <i class="conum" data-value="1"></i><b>(1)</b>
public class Echo {

   public String echo(String val) {
      return val;
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>AdditionalBeanBuildItem</code> で登録された Bean がスコープを指定しない場合は <code>@Dependent</code> とする。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>他のすべての Bean は、このような Bean を注入することができます。</p>
</div>
<div class="listingblock">
<div class="title"><code>AdditionalBeanBuildItem</code> によって構築された Bean をインジェクトするBean</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Path("/hello")
public class ExampleResource {

    @Inject
    Echo echo;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello(String foo) {
        return echo.echo(foo);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、その逆に、 エクステンション Bean は、他のエクステンションによって提供されるアプリケーション Bean やアプリケーション Bean を注入することができます。</p>
</div>
<div class="listingblock">
<div class="title">エクステンション Bean インジェクト例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Singleton
public class Echo {

    @Inject
    DataSource dataSource;  <i class="conum" data-value="1"></i><b>(1)</b>

    @Inject
    Instance&lt;List&lt;String&gt;&gt; listsOfStrings; <i class="conum" data-value="2"></i><b>(2)</b>

    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>他のエクステンションで提供されているBeanをインジェクトします。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>タイプ <code>List&lt;String&gt;</code> に一致するすべてのBeanを注入します。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="bean_init"><a class="anchor" href="#bean_init"></a>1.4.2. Bean initialization</h4>
<div class="paragraph">
<p>コンポーネントによっては、拡張中に収集された情報に基づいて、追加の初期化が必要になる場合があります。最も簡単な解決策は、Bean のインスタンスを取得し、ビルドステップから直接メソッドを呼び出すことです。しかし、拡張フェーズ中にBeanインスタンスを取得することは <em>違反</em> です。理由は、CDIコンテナがまだ起動していないからです。CDIコンテナは <a href="#bootstrap-three-phases">Static initブートストラップフェーズ</a> の間に起動されています。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>BUILD_AND_RUN_TIME_FIXED</code> と <code>RUN_TIME</code> 設定ルートは、どのBeanにも注入することができます。 <code>RUN_TIME</code> 設定ルールは、ブートストラップの後にのみ注入すべきです。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>しかし、 <a href="#bytecode-recording">recorderメソッド</a> からBeanメソッドを呼び出すことは可能です。 <code>@Record(STATIC_INIT)</code> ビルドステップで Bean にアクセスする必要がある場合は、 <code>BeanContainerBuildItem</code> に依存するか、 <code>BeanContainerListenerBuildItem</code> でロジックをラップしなければなりません。理由は簡単で、CDIコンテナが完全に初期化されて起動していることを確認する必要があるからです。しかし、CDI コンテナは <code>@Record(RUNTIME_INIT)</code> ビルドステップで完全に初期化されて実行されていると思っておいた方が安全です。コンテナへの参照は、 <code>CDI.current()</code> またはQuarkus固有の <code>Arc.container()</code> .</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Beanの状態が可視性を保証していることを担保することを忘れないでください。たとえば、<code>volatile</code> キーワードです。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
この「遅延初期化」アプローチには、1つの重大な欠点があります。 <em>初期化されていない</em> Beanは、ブートストラップ中にインスタンス化された他のエクステンションやアプリケーションコンポーネントからアクセスされる可能性があります。 <a href="#synthetic_beans">synthetic_beans</a>] で、よりロバストな解決策を取り上げます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="デフォルトのbean"><a class="anchor" href="#デフォルトのbean"></a>1.4.3. デフォルトのBean</h4>
<div class="paragraph">
<p>このような Bean を作成しつつ、アプリケーションコードにカスタム実装で Bean の一部を簡単にオーバーライドする機能を与えるという非常に便利なパターンは、Quarkusが提供している <code>@DefaultBean</code> を使用することです。これは例を挙げて説明するのが一番です。</p>
</div>
<div class="paragraph">
<p>ここでは、Quarkusエクステンションが <code>Tracer</code> Bean を提供する必要があると仮定して、アプリケーションコードがそれ自身の Bean に注入することを意味します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Dependent
public class TracerConfiguration {

    @Produces
    public Tracer tracer(Reporter reporter, Configuration configuration) {
        return new Tracer(reporter, configuration);
    }

    @Produces
    @DefaultBean
    public Configuration configuration() {
        // create a Configuration
    }

    @Produces
    @DefaultBean
    public Reporter reporter(){
        // create a Reporter
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>例えば、アプリケーションコードが <code>Tracer</code> を使用したいが、カスタムの <code>Reporter</code> Bean を使用する必要がある場合、そのような要件は、次のようなものを使用して簡単に行うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Dependent
public class CustomTracerConfiguration {

    @Produces
    public Reporter reporter(){
        // create a custom Reporter
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-override-a-bean-defined-by-a-libraryquarkus-extension-that-doesnt-use-defaultbean"><a class="anchor" href="#how-to-override-a-bean-defined-by-a-libraryquarkus-extension-that-doesnt-use-defaultbean"></a>1.4.4. How to Override a Bean Defined by a Library/Quarkus Extension that doesn&#8217;t use @DefaultBean</h4>
<div class="paragraph">
<p><code>@DefaultBean</code> が推奨されていますが、CDI <code>@Alternative</code> としてBeanをマークし、 <code>@Priority</code> アノテーションを含めることで、アプリケーションコードがエクステンションによって提供されるBeanをオーバーライドすることも可能です。簡単な例を示しましょう。架空の"quarkus-parser"エクステンションで作業をしていて、デフォルトのBeanの実装を持っているとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Dependent
class Parser {

  String[] parse(String expression) {
    return expression.split("::");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、私たちのエクステンションはこのパーサも消費します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@ApplicationScoped
class ParserService {

  @Inject
  Parser parser;

  //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>さて、ユーザーや他のエクステンションが <code>Parser</code> のデフォルトの実装を上書きする必要がある場合、最も簡単な解決策は CDI <code>@Alternative</code> + <code>@Priority</code> を使用することです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Alternative <i class="conum" data-value="1"></i><b>(1)</b>
@Priority(1) <i class="conum" data-value="2"></i><b>(2)</b>
@Singleton
class MyParser extends Parser {

  String[] parse(String expression) {
    // my super impl...
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>MyParser</code> は代替 Beanです。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>代替 Beanを有効にします。優先度はデフォルトの Bean を上書きするために任意の数値を指定できますが、複数の代替 Bean がある場合は、最も高い優先度のものが優先されます。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
CDI の代替 Beanは、インジェクションと型安全解決の間のみ考慮されます。例えば、デフォルトの実装では、オブザーバー通知を受け取ることになります。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="synthetic_beans"><a class="anchor" href="#synthetic_beans"></a>1.4.5. 合成Bean</h4>
<div class="paragraph">
<p>合成 Beanを登録できると非常に便利なことがあります。合成 Beanのビーン属性は，javaクラス，メソッド，フィールドから派生したものではありません。その代わりに、属性はエクステンションによって指定されます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
CDIコンテナは合成Beanのインスタンス化を制御しないので、依存性注入や他のサービス(インターセプタなど)はサポートされていません。言い換えれば、合成 Bean のインスタンスに必要なすべてのサービスを提供するのはエクステンション次第ということです。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Quarkusで <a href="cdi-reference.html#synthetic_beans">合成Bean</a> を登録する方法はいくつかあります。この章では、（ <a href="#bean_init">[bean_init</a>] と比較して）安全な方法でエクステンションBeanを初期化できるユースケースを取り上げます。</p>
</div>
<div class="paragraph">
<p><code>SyntheticBeanBuildItem</code> で合成 Bean を登録することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>そのインスタンスは、 <a href="#bytecode-recording">レコーダー</a> を介して簡単に生成することができます。</p>
</li>
<li>
<p>実際のコンポーネントはコンテキスト Beanを直接注入することができるので"遅延初期化"を必要としないように、拡張中に収集されたすべての情報を保持する"コンテキスト" Beanを提供します。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">レコーダーを通して生成されたインスタンス</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(STATIC_INIT)
SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {
   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)
                .runtimeValue(recorder.createFoo("parameters are recorder in the bytecode")) <i class="conum" data-value="1"></i><b>(1)</b>
                .done();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>文字列の値はバイトコードに記録され、 <code>Foo</code> のインスタンス初期化に使用されます。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">"コンテキスト"ホルダー</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(STATIC_INIT)
SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {
   return SyntheticBeanBuildItem.configure(TestContext.class).scope(Singleton.class)
                .runtimeValue(recorder.createContext("parameters are recorder in the bytecode")) <i class="conum" data-value="1"></i><b>(1)</b>
                .done();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>「本物の」コンポーネントは、 <code>TestContext</code> を直接注入することができます。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションのタイプ"><a class="anchor" href="#エクステンションのタイプ"></a>1.5. エクステンションのタイプ</h3>
<div class="paragraph">
<p>エクステンションの定型的なタイプは複数存在しますが、いくつか挙げてみましょう。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ベアライブラリの実行</dt>
<dd>
<p>これはあまり洗練されていないエクステンションです。これは、ライブラリがGraalVM上で動作するようにするためのパッチのセットで構成されています。可能であれば、これらのパッチはエクステンションの中ではなく、アップストリームで貢献してください。二番目に良いのは、ネイティブイメージのコンパイル時に適用されるパッチである Substrate VM 置換を書くことです。</p>
</dd>
<dt class="hdlist1">実行中のフレームワークを取得する</dt>
<dd>
<p>実行時のフレームワークは通常、設定を読み込み、クラスパスとクラスをスキャンしてメタデータ(アノテーションやゲッターなど)を探し、その上にメタモデルを構築し、サービスローダパターンを介してオプションを見つけ、実行呼び出し(リフレクション)やプロキシインターフェイスなどを準備します。これらの操作はビルド時に行われ、メタモデルは実行時に実行されるクラスを生成するレコーダDSLに渡され、フレームワークを起動します。</p>
</dd>
<dt class="hdlist1">Get a CDI portable extension running</dt>
<dd>
<p>CDIポータブルエクステンションモデルは非常に柔軟性が高いです。Quarkusが推進するビルドタイムブートの恩恵を受けるには、あまりにも柔軟性が高すぎます。私たちが見てきたほとんどのエクステンションは、このような極端な柔軟性の機能を利用していません。CDIエクステンションをQuarkusに移植する方法は、ビルド時（エクステンションの言い方ではデプロイ時）に様々なBeanを定義するQuarkusエクステンションとして書き換えることです。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="技術的な側面"><a class="anchor" href="#技術的な側面"></a>2. 技術的な側面</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="bootstrap-three-phases"><a class="anchor" href="#bootstrap-three-phases"></a>2.1. Three Phases of Bootstrap and Quarkus Philosophy</h3>
<div class="paragraph">
<p>Quarkusアプリには、3つの異なるブートストラップフェーズがあります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">拡張</dt>
<dd>
<p>これは最初のフェーズであり、 link:#Build Step Processors[Build Step Processors]によって行われます。これらのプロセッサはJandexのアノテーション情報にアクセスすることができ、任意の記述子を解析してアノテーションを読み取ることができますが、任意のアプリケーションクラスのロードを試みるべきではありません。これらのビルドステップの出力は、Gizmo(ext/gizmo)と呼ばれるObjectWeb ASMプロジェクトのエクステンションを使用して、記録されたバイトコードであり、実行時にアプリケーションを実際にブートストラップするために使用されます。ビルド・ステップに関連する <code>@io.quarkus.deployment.annotations.Record</code> アノテーションの <code>io.quarkus.deployment.annotations.ExecutionTime</code> 値に応じて、そのステップは以下の2つのモードに基づいて異なるJVMで実行されることがあります。</p>
</dd>
<dt class="hdlist1">スタティック初期化</dt>
<dd>
<p><code>@Record(STATIC_INIT)</code> でバイトコードが記録されている場合は、mainクラスのスタティック初期化メソッドから実行されます。ネイティブビルドの場合、このコードはネイティブビルドプロセスの一部として通常のJVMで実行され、この段階で生成されたリテインドオブジェクトは、イメージマップされたファイルを介してネイティブ実行可能ファイルに直接シリアル化されます。つまり、この段階でフレームワークが起動できれば、そのフレームワークの起動状態がイメージに直接書き込まれるため、イメージの起動時にブートコードを実行する必要がありません。</p>
<div class="paragraph">
<p>この段階では、サブストレートVMがネイティブ実行可能ファイルに含まれるいくつかのオブジェクトを許可しないため、実行できる内容にいくつかの制限があります。例えば、この段階でポートのリッスンやスレッドの開始を試みてはいけません。また、スタティック初期化時に実行時設定を読み取ることも禁止されています。</p>
</div>
<div class="paragraph">
<p>非ネイティブのピュアJVMモードでは、スタティック起動とランタイム起動に実質的な違いはありませんが、スタティック起動が常に最初に実行されることが異なります。このモードでは、記述子の解析とアノテーションのスキャンがビルド時に行われ、関連するクラスやフレームワークの依存関係がビルド出力jarから削除されるため、ネイティブモードと同様のビルドフェーズのエクステンションが利用できます。WildFlyのようなサーバーでは、XMLパーサーなどの展開関連クラスがアプリケーションの存続期間中、貴重なメモリを使用してぶら下がっています。Quarkusは、このようなことをなくし、実行時にロードされるクラスのみが実行時に実際に使用されるようにすることを目指しています。</p>
</div>
<div class="paragraph">
<p>例として、QuarkusアプリケーションがXMLパーサーをロードする理由は、ユーザーがアプリケーションでXMLを使用している場合のみです。どの設定のXMLパースも、拡張フェーズで行う必要があります。</p>
</div>
</dd>
<dt class="hdlist1">ランタイム初期化</dt>
<dd>
<p><code>@Record(RUNTIME_INIT)</code> でバイトコードが記録されている場合は、アプリケーションのメインメソッドから実行されます。このコードはネイティブ実行可能ファイルブートで実行されます。一般的に、このフェーズではできるだけ少ないコードを実行すべきであり、ポートを開く必要があるコードなどに限定すべきです。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>@Record(STATIC_INIT)</code> フェーズにできるだけ多くのものを押し込むことで、2つの異なる最適化が可能になります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ネイティブ実行可能ファイルとピュアJVMの両方のモードで、これによりビルド時に処理が行われたため、アプリを可能な限り高速に起動することができます。また、アプリケーションに必要なクラスやネイティブコードを最小限に抑え、純粋な実行時関連の動作を実現します。</p>
</li>
<li>
<p>ネイティブ実行可能ファイルモードのもう一つの利点は、サブストレートが使われない機能をより簡単に排除できることです。機能がバイトコードで直接初期化される場合、Substrateはメソッドが一度も呼ばれていないことを検知し、そのメソッドを削除することができます。また、実行時に設定を読み込む場合、サブストレートは設定の内容を推論することができないため、必要な場合に備えてすべての機能を残しておく必要があります。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="プロジェクトのセットアップ"><a class="anchor" href="#プロジェクトのセットアップ"></a>2.2. プロジェクトのセットアップ</h3>
<div class="paragraph">
<p>エクステンションプロジェクトは、2つのサブモジュールを持つマルチモジュールプロジェクトとして設定する必要があります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ビルド時の処理やバイトコードの記録を行うデプロイメント時サブモジュール</p>
</li>
<li>
<p>ネイティブ実行可能ファイルまたはランタイムJVMでエクステンション動作を提供する実行時動作を含むランタイムサブモジュール</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>実行時アーティファクトは、 <code>io.quarkus:quarkus-core</code> や 、おそらく他のQuarkusモジュールの実行時アーティファクトに依存する必要があります。デプロイメント時モジュールは、 <code>io.quarkus:quarkus-core-deployment</code> や、実行時アーティファクト、およびおそらく他のQuarkusモジュールが提供する機能を使用したい場合は、そのデプロイメントアーティファクトに依存する必要があります。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>いかなる場合でも、実行時モジュールはデプロイメントアーティファクトに依存することはできません。これは、すべてのデプロイメント時のコードが実行時スコープに取り込まれることに繋がり、分割の目的を台無しにします。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-maven"><a class="anchor" href="#using-maven"></a>2.2.1. Using Maven</h4>
<div class="paragraph">
<p>ランタイムアーティファクトに含まれるQuarkusエクステンション記述子を生成するために、 <code>io.quarkus:quarkus-bootstrap-maven-plugin</code> をインクルードする必要があります。さらに、 <code>quarkus-extension-processor</code> アノテーションプロセッサを検出するために、 <code>maven-compiler-plugin</code> を設定する必要があります。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>io.quarkus:quarkus-maven-plugin</code> の <code>create-extension</code> mojo は、新しい Quarkus エクステンションの実装に必要な Maven モジュールのスタブを生成するために使用できます。次のセクションをご覧ください。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
規約として、デプロイメント時アーティファクトには <code>-deployment</code> というサフィックスを付け、実行時アーティファクトにはサフィックスを付けません（エンドユーザーが自分のプロジェクトに追加するものです）。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-core&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-bootstrap-maven-plugin&lt;/artifactId&gt;
            &lt;!-- Executions configuration can be inherited from quarkus-build-parent --&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;extension-descriptor&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                         &lt;deployment&gt;${project.groupId}:${project.artifactId}-deployment:${project.version}&lt;/deployment&gt;
                   &lt;/configuration&gt;
               &lt;/execution&gt;
           &lt;/executions&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                        &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上記の <code>maven-compiler-plugin</code> の設定には、バージョン 3.5+ が必要です。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>また、<code>quarkus-extension-processor</code> アノテーションプロセッサを検出するようデプロイメントモジュールの <code>maven-compiler-plugin</code> を設定する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-core-deployment&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                        &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="create-new-quarkus-core-extension-modules-using-maven"><a class="anchor" href="#create-new-quarkus-core-extension-modules-using-maven"></a>2.2.1.1. Create new Quarkus Core extension modules using Maven</h5>
<div class="paragraph">
<p>Quarkus は、 <code>create-extension</code> Maven Mojo を提供し、拡張プロジェクトを初期化します。</p>
</div>
<div class="paragraph">
<p>オプションの自動検出が試行されます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus</code> (Quarkus Core) または <code>quarkus/extensions</code> ディレクトリからアクセスすると、'Quarkus Core' エクステンションのレイアウトとデフォルトが使用されます。</p>
</li>
<li>
<p><code>-DgroupId=io.quarkiverse.[extensionId]</code> を使用すると、'Quarkiverse' エクステンションのレイアウトとデフォルトを使用します。</p>
</li>
<li>
<p>それ以外の場合は 'Standalone' エクステンションのレイアウトとデフォルトを使用します。</p>
</li>
<li>
<p>将来的には他のレイアウトタイプを導入する可能性があります。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
インタラクティブ・モードを使用する場合は、パラメータを指定する必要はありません: <code>mvn io.quarkus.platform:quarkus-maven-plugin:999-SNAPSHOT:create-extension -N</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例として、 <code>my-ext</code> という新しいエクステンションをQuarkusのソースツリーに追加してみましょう:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">git clone https://github.com/quarkusio/quarkus.git
cd quarkus
mvn io.quarkus.platform:quarkus-maven-plugin:999-SNAPSHOT:create-extension -N \
    -DextensionId=my-ext \
    -Dname="My Extension"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
デフォルトでは、 <code>groupId</code>, <code>version</code>, <code>quarkusVersion</code>, <code>namespaceId</code>, <code>namespaceName</code> は、他のQuarkusコアエクステンションと一致します。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上記の一連のコマンドは、次のような動作をします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>4つの新しいMavenモジュールを作成します。</p>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-my-ext-parent</code> in the <code>extensions/my-ext</code> directory</p>
</li>
<li>
<p><code>quarkus-my-ext</code> in the <code>extensions/my-ext/runtime</code> directory</p>
</li>
<li>
<p><code>extensions/my-ext/deployment</code> ディレクトリに <code>quarkus-my-ext-deployment</code> ; 基本的な <code>MyExtProcessor</code> クラスはこのモジュールで生成されます。</p>
</li>
<li>
<p><code>integration-tests/my-ext/deployment</code> ディレクトリに <code>quarkus-my-ext-integration-test</code> ; 空の JAX-RS Resource クラスと 2 つのテストクラス (JVM モードとネイティブモード用) がこのモジュールで生成されます。</p>
</li>
</ul>
</div>
</li>
<li>
<p>必要に応じて、これらの3つのモジュールをリンクします。</p>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-my-ext-parent</code> is added to the <code>&lt;modules&gt;</code> of <code>quarkus-extensions-parent</code></p>
</li>
<li>
<p>QuarkusのBOM（Bill of Materials） <code>bom/application/pom.xml</code> の <code>&lt;dependencyManagement&gt;</code> に <code>quarkus-my-ext</code> が追加されます。</p>
</li>
<li>
<p>QuarkusのBOM（Bill of Materials） <code>bom/application/pom.xml</code> の <code>&lt;dependencyManagement&gt;</code> に <code>quarkus-my-ext-deployment</code> が追加されます。</p>
</li>
<li>
<p><code>quarkus-my-ext-integration-test</code> is added to the <code>&lt;modules&gt;</code> of <code>quarkus-integration-tests-parent</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
また、実行時モジュールの <code>src/main/resources/META-INF</code> フォルダー内の、エクステンションについて説明する <code>quarkus-extension.yaml</code> ファイルを記入する必要があります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>これは、 <code>quarkus-agroal</code> エクステンションの <code>quarkus-extension.yaml</code> です。手本として使用することができます:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: "Agroal - Database connection pool"
metadata:
  keywords:
  - "agroal"
  - "database-connection-pool"
  - "datasource"
  - "jdbc"
  guide: "https://quarkus.io/guides/datasource"
  categories:
  - "data"
  status: "stable"</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
mojoの <code>name</code> パラメータはオプションです。コマンドラインで指定しなかった場合、プラグインは <code>extensionId</code> からダッシュをスペースに置き換え、各トークンを大文字にすることで導出します。そのため、場合によっては明示的な <code>name</code> を省略することも考えられます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mojoで使用できるすべてのオプションについては、 <a href="https://github.com/quarkusio/quarkus/blob/999-SNAPSHOT/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java">CreateExtensionMojoのJavaDoc</a>を参照してください。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-gradle"><a class="anchor" href="#using-gradle"></a>2.2.2. Using Gradle</h4>
<div class="paragraph">
<p>エクステンションプロジェクトの <code>runtime</code> モジュールに <code>io.quarkus.extension</code> プラグインを適用する必要があります。このプラグインには、 <code>META-INF/quarkus-extension.properties</code> と <code>META-INF/quarkus-extension.yml</code> のファイルを生成する <code>extensionDescriptor</code> タスクが含まれています。また、このプラグインは <code>deployment</code> と <code>runtime</code> の両方のモジュールで <code>io.quarkus:quarkus-extension-processor</code> アノテーションプロセッサを有効にします。デプロイメントモジュールの名前は、プラグインで <code>deploymentArtifact</code> プロパティを設定することで設定できます。このプロパティは、デフォルトでは <code>deployment</code> に設定されています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    id 'java'
    id 'io.quarkus.extensions'
}

quarkusExtension {
    deploymentArtifact = 'deployment'
}

dependencies {
    implementation platform('io.quarkus:quarkus-bom:999-SNAPSHOT')
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このプラグインはまだ実験的なもので、同等のMavenプラグインが行うようなエクステンションの依存関係の検証は行いません。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ビルドステッププロセッサー"><a class="anchor" href="#ビルドステッププロセッサー"></a>2.3. ビルドステッププロセッサー</h3>
<div class="paragraph">
<p>作業は、 <em>ビルドアイテム</em> を生成・消費する <em>ビルドステップ</em> によって拡張時に行われます。プロジェクトビルドのエクステンションに対応するデプロイメント・モジュール内のビルドステップは、自動的に接続され、最終的なビルドアーティファクトを生成するために実行されます。</p>
</div>
<div class="sect3">
<h4 id="ビルドステップ"><a class="anchor" href="#ビルドステップ"></a>2.3.1. ビルドステップ</h4>
<div class="paragraph">
<p><em>ビルドステップ</em> は、 <code>@io.quarkus.deployment.annotations.BuildStep</code> アノテーションが付与された非静的なメソッドです。各ビルドステップは、前のステージで生成されたアイテムを <a href="#consuming-values">消費したり</a> 、後のステージで消費できるアイテムを <a href="#producing-values">生成したり</a>します。ビルドステップは通常、最終的に他のステップで消費されるビルドアイテムを生成するときにのみ実行されます。</p>
</div>
<div class="paragraph">
<p>ビルドステップは通常、エクステンションのデプロイメントモジュール内のプレーンなクラスに配置されます。このクラスは、拡張プロセス中に自動的にインスタンス化され、 <a href="#injection">インジェクション</a>を利用します。</p>
</div>
</div>
<div class="sect3">
<h4 id="build-items"><a class="anchor" href="#build-items"></a>2.3.2. ビルドアイテム</h4>
<div class="paragraph">
<p>ビルドアイテムは、abstractな <code>io.quarkus.builder.item.BuildItem</code> クラスのfinalな具象サブクラスです。それぞれのビルドアイテムは、あるステージから別のステージに渡す必要のある情報の単位を表します。ベースとなる <code>BuildItem</code> クラスは、それ自体を直接サブクラス化することはできません。むしろ、作成 <em>可能な</em> ビルドアイテムのサブクラスの種類（ <a href="#simple-build-items">シンプル</a>、 <a href="#multi-build-items">マルチ</a>、 <a href="#empty-build-items">空</a>）ごとに抽象サブクラスがあります。</p>
</div>
<div class="paragraph">
<p>ビルドアイテムは、異なるエクステンションが相互に通信するための手段と考えてください。例えば、ビルドアイテムは以下のことができます:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>expose the fact that a database configuration exists</p>
</li>
<li>
<p>データベースの設定を利用する（例：コネクションプールエクステンション、ORMエクステンション）</p>
</li>
<li>
<p>ask an extension to do work for another extension: e.g. an extension wanting to define a new CDI bean and asking the ArC extension to do so</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これは非常に柔軟なメカニズムです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>BuildItem</code> インスタンスはイミュータブルでなければなりません。プロデューサー/コンシューマーモデルでは、ミューテーションを正しく順序付けることができないからです。これは強制されるものではありませんが、このルールに従わないと競合状態になる可能性があります。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="simple-build-items"><a class="anchor" href="#simple-build-items"></a>2.3.2.1. シンプルなビルドアイテム</h5>
<div class="paragraph">
<p>シンプルビルドアイテムは <code>io.quarkus.builder.item.SimpleBuildItem</code> を拡張したfinalクラスです。シンプルビルドアイテムは、特定のビルドにおいて、1つのステップでのみ作成できます。ビルド内の複数のステップが同じシンプルビルドアイテムを生成すると宣言した場合、エラーが発生します。シンプルビルドアイテムを利用するビルドステップは、常にそのアイテムを生成したビルドステップの <em>後に</em> 実行されます。</p>
</div>
<div class="listingblock">
<div class="title">Example of a single build item</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * The build item which represents the Jandex index of the application,
 * and would normally be used by many build steps to find usages
 * of annotations.
 */
public final class ApplicationIndexBuildItem extends SimpleBuildItem {

    private final Index index;

    public ApplicationIndexBuildItem(Index index) {
        this.index = index;
    }

    public Index getIndex() {
        return index;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="multi-build-items"><a class="anchor" href="#multi-build-items"></a>2.3.2.2. マルチビルドアイテム</h5>
<div class="paragraph">
<p>マルチビルドアイテムは、 <code>io.quarkus.builder.item.MultiBuildItem</code> を拡張したfinalクラスです。あるクラスのマルチビルドアイテムは、任意の数のステップで、任意の数生成できますが、マルチビルドアイテムを利用するステップは、それらを生成できるすべてのステップが実行された後のみ実行されます。</p>
</div>
<div class="listingblock">
<div class="title">マルチビルドアイテムの例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public final class ServiceWriterBuildItem extends MultiBuildItem {
    private final String serviceName;
    private final List&lt;String&gt; implementations;

    public ServiceWriterBuildItem(String serviceName, String... implementations) {
        this.serviceName = serviceName;
        // Make sure it's immutable
        this.implementations = Collections.unmodifiableList(
            Arrays.asList(
                implementations.clone()
            )
        );
    }

    public String getServiceName() {
        return serviceName;
    }

    public List&lt;String&gt; getImplementations() {
        return implementations;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">マルチビルドアイテムの使用例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This build step produces a single multi build item that declares two
 * providers of one configuration-related service.
 */
@BuildStep
public ServiceWriterBuildItem registerOneService() {
    return new ServiceWriterBuildItem(
        Converter.class.getName(),
        MyFirstConfigConverterImpl.class.getName(),
        MySecondConfigConverterImpl.class.getName()
    );
}

/**
 * This build step produces several multi build items that declare multiple
 * providers of multiple configuration-related services.
 */
@BuildStep
public void registerSeveralServices(
    BuildProducer&lt;ServiceWriterBuildItem&gt; providerProducer
) {
    providerProducer.produce(new ServiceWriterBuildItem(
        Converter.class.getName(),
        MyThirdConfigConverterImpl.class.getName(),
        MyFourthConfigConverterImpl.class.getName()
    ));
    providerProducer.produce(new ServiceWriterBuildItem(
        ConfigSource.class.getName(),
        MyConfigSourceImpl.class.getName()
    ));
}

/**
 * This build step aggregates all the produced service providers
 * and outputs them as resources.
 */
@BuildStep
public void produceServiceFiles(
    List&lt;ServiceWriterBuildItem&gt; items,
    BuildProducer&lt;GeneratedResourceBuildItem&gt; resourceProducer
) throws IOException {
    // Aggregate all of the providers

    Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
    for (ServiceWriterBuildItem item : items) {
        String serviceName = item.getName();
        for (String implName : item.getImplementations()) {
            map.computeIfAbsent(
                serviceName,
                (k, v) -&gt; new LinkedHashSet&lt;&gt;()
            ).add(implName);
        }
    }

    // Now produce the resource(s) for the SPI files
    for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : map.entrySet()) {
        String serviceName = entry.getKey();
        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
            try (OutputStreamWriter w = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {
                for (String implName : entry.getValue()) {
                    w.write(implName);
                    w.write(System.lineSeparator());
                }
                w.flush();
            }
            resourceProducer.produce(
                new GeneratedResourceBuildItem(
                    "META-INF/services/" + serviceName,
                    os.toByteArray()
                )
            );
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="empty-build-items"><a class="anchor" href="#empty-build-items"></a>2.3.2.3. 空のビルドアイテム</h5>
<div class="paragraph">
<p>空のビルドアイテムは、 <code>io.quarkus.builder.item.EmptyBuildItem</code> を拡張するfinalの（通常は空の）クラスです。空のビルドアイテムは、実際には何のデータも持たないビルドアイテムを表しており、空のクラスをインスタンス化することなく、そのようなアイテムを生成したり消費したりすることができます。空のクラスは、それ自体をインスタンス化することはできません。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
As they cannot be instantiated, they cannot be injected by any means, nor be returned by a build step (or via a <code>BuildProducer</code>). To produce an empty build item you must annotate the build step with <code>@Produce(MyEmptyBuildItem.class)</code> and to consume it by <code>@Consume(MyEmptyBuildItem.class)</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">空のビルドアイテムの例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public final class NativeImageBuildItem extends EmptyBuildItem {
    // empty
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>空のビルドアイテムは、ステップ間の順序付けを可能にする「バリア」を表すことができます。また、一般的なビルドシステムが「疑似ターゲット」を使用するのと同じように、空のビルドアイテムを使用することもできます。</p>
</div>
<div class="listingblock">
<div class="title">空のビルドアイテムを「疑似ターゲット」スタイルで使用する例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * Contrived build step that produces the native image on disk.  The main augmentation
 * step (which is run by Maven or Gradle) would be declared to consume this empty item,
 * causing this step to be run.
 */
@BuildStep
@Produce(NativeImageBuildItem.class)
void produceNativeImage() {
    // ...
    // (produce the native image)
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">空のビルドアイテムを "バリア "スタイルで使用した例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This would always run after {@link #produceNativeImage()} completes, producing
 * an instance of {@code SomeOtherBuildItem}.
 */
@BuildStep
@Consume(NativeImageBuildItem.class)
SomeOtherBuildItem secondBuildStep() {
    return new SomeOtherBuildItem("foobar");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injection"><a class="anchor" href="#injection"></a>2.3.3. 注入</h4>
<div class="paragraph">
<p>ビルドステップを含むクラスは、以下のタイプのインジェクションに対応しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>コンストラクタパラメータ・インジェクション</p>
</li>
<li>
<p>フィールド・インジェクション</p>
</li>
<li>
<p>メソッドパラメータ・インジェクション（ビルドステップ・メソッドの場合のみ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ビルド・ステップ・クラスは、ビルド・ステップを呼び出すたびにインスタンス化され、注入され、その後は破棄されます。ビルドステップ間では、たとえ同じクラスであっても、ビルドアイテムを介してのみ状態が伝達されるべきです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
finalフィールドはインジェクションの対象にはなりませんが、必要に応じてコンストラクタのパラメータインジェクションで入力することができます。staticフィールドは、インジェクションの対象にはなりません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>注入可能な値の種類は以下の通りです:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>前のビルドステップで生成された <a href="#build-items">ビルドアイテム</a></p>
</li>
<li>
<p>後続のビルドステップのためにアイテムを生産する <a href="#producing-values">ビルドプロデューサー</a></p>
</li>
<li>
<p><a href="#configuration-roots">設定ルート</a>の種類</p>
</li>
<li>
<p><a href="#bytecode-recording">バイトコード記録</a>用のテンプレートオブジェクト</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
ビルドステップのメソッドやそのクラスに注入されたオブジェクトは、そのメソッドの実行時以外に使用しては <em>いけません</em> 。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
インジェクションは、アノテーション・プロセッサを介してコンパイル時に解決され、生成されたコードは、プライベート・フィールドを注入したり、プライベート・メソッドを呼び出したりする権限を持ちません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="producing-values"><a class="anchor" href="#producing-values"></a>2.3.4. 値の生成</h4>
<div class="paragraph">
<p>ビルドステップは、いくつかの可能な方法で後続のステップのために値を生成することができます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#simple-build-items">シンプルビルドアイテム</a>や <a href="#multi-build-items">マルチビルドアイテム</a>のインスタンスを返すことで</p>
</li>
<li>
<p>マルチビルドアイテムクラスの <code>List</code> を返すことで</p>
</li>
<li>
<p>By injecting a <code>BuildProducer</code> of a simple or multi build item class</p>
</li>
<li>
<p>By annotating the method with <code>@io.quarkus.deployment.annotations.Produce</code>, giving the class name of a <a href="#empty-build-items">empty build item</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a simple build item is declared on a build step, it <em>must</em> be produced during that build step, otherwise an error will result. Build producers which are injected into steps <em>must not</em> be used outside of that step.</p>
</div>
<div class="paragraph">
<p>Note that a <code>@BuildStep</code> method will only be called if it produces something that another consumer or the final output requires. If there is no consumer for a particular item then it will not be produced. What is required will depend on the final target that is being produced. For example, when running in developer mode the final output will not ask for GraalVM-specific build items such as <code>ReflectiveClassBuildItem</code>, so methods that only produce these items will not be invoked.</p>
</div>
</div>
<div class="sect3">
<h4 id="consuming-values"><a class="anchor" href="#consuming-values"></a>2.3.5. 値の利用</h4>
<div class="paragraph">
<p>ビルドステップは、以下の方法で前のステップの値を利用することができます:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#simple-build-items">シンプルビルドアイテム</a>を注入することで</p>
</li>
<li>
<p>シンプルビルドアイテムクラスの <code>Optional</code> を注入することで</p>
</li>
<li>
<p><a href="#multi-build-items">マルチビルドアイテムクラス</a>の <code>List</code> を注入することで</p>
</li>
<li>
<p>By annotating the method with <code>@io.quarkus.deployment.annotations.Consume</code>, giving the class name of a <a href="#empty-build-items">empty build item</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Normally it is an error for a step which is included to consume a simple build item that is not produced by any other step. In this way, it is guaranteed that all of the declared values will be present and non-<code>null</code> when a step is run.</p>
</div>
<div class="paragraph">
<p>Sometimes a value isn&#8217;t necessary for the build to complete, but might inform some behavior of the build step if it is present. In this case, the value can be optionally injected.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multi build values are always considered <em>optional</em>. If not present, an empty list will be injected.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="producing-weak-values"><a class="anchor" href="#producing-weak-values"></a>2.3.5.1. 弱い値の生成</h5>
<div class="paragraph">
<p>Normally a build step is included whenever it produces any build item which is in turn consumed by any other build step. In this way, only the steps necessary to produce the final artifact(s) are included, and steps which pertain to extensions which are not installed or which only produce build items which are not relevant for the given artifact type are excluded.</p>
</div>
<div class="paragraph">
<p>For cases where this is not desired behavior, the <code>@io.quarkus.deployment.annotations.Weak</code> annotation may be used. This annotation indicates that the build step should not automatically be included solely on the basis of producing the annotated value.</p>
</div>
<div class="listingblock">
<div class="title">Example of producing a build item weakly</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This build step is only run if something consumes the ExecutorClassBuildItem.
 */
@BuildStep
void createExecutor(
        @Weak BuildProducer&lt;GeneratedClassBuildItem&gt; classConsumer,
        BuildProducer&lt;ExecutorClassBuildItem&gt; executorClassConsumer
) {
        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);
        String className = generateClassThatCreatesExecutor(cw); <i class="conum" data-value="1"></i><b>(1)</b>
        classConsumer.produce(new GeneratedClassBuildItem(true, className, cw.toByteArray()));
        executorClassConsumer.produce(new ExecutorClassBuildItem(className));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This method (not provided in this example) would generate the class using the ASM API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Certain types of build items are generally always consumed, such as generated classes or resources. An extension might produce a build item along with a generated class to facilitate the usage of that build item. Such a build step would use the <code>@Weak</code> annotation on the generated class build item, while normally producing the other build item. If the other build item is ultimately consumed by something, then the step would run and the class would be generated. If nothing consumes the other build item, the step would not be included in the build process.</p>
</div>
<div class="paragraph">
<p>In the example above, <code>GeneratedClassBuildItem</code> would only be produced if <code>ExecutorClassBuildItem</code> is consumed by some other build step.</p>
</div>
<div class="paragraph">
<p>Note that when using <a href="#bytecode-recording">bytecode recording</a>, the implicitly generated class can be declared to be weak by using the <code>optional</code> attribute of the <code>@io.quarkus.deployment.annotations.Record</code> annotation.</p>
</div>
<div class="listingblock">
<div class="title">Example of using a bytecode recorder where the generated class is weakly produced</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This build step is only run if something consumes the ExecutorBuildItem.
 */
@BuildStep
@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) <i class="conum" data-value="1"></i><b>(1)</b>
ExecutorBuildItem createExecutor( <i class="conum" data-value="2"></i><b>(2)</b>
        ExecutorTemplate executorTemplate,
        ThreadPoolConfig threadPoolConfig
) {

    return new ExecutorBuildItem(
        setupTemplate.setupRunTime(
            shutdownContextBuildItem,
            threadPoolConfig,
            launchModeBuildItem.getLaunchMode()
        )
    );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the <code>optional</code> attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This example is using recorder proxies; see the section on <a href="#bytecode-recording">bytecode recording</a> for more information.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="アプリケーションアーカイブ"><a class="anchor" href="#アプリケーションアーカイブ"></a>2.3.6. アプリケーションアーカイブ</h4>
<div class="paragraph">
<p>The <code>@BuildStep</code> annotation can also register marker files that determine which archives on the class path are considered to be 'Application Archives', and will therefore get indexed. This is done via the <code>applicationArchiveMarkers</code>. For example the ArC extension registers <code>META-INF/beans.xml</code>, which means that all archives on the class path with a <code>beans.xml</code> file will be indexed.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-threads-context-class-loader"><a class="anchor" href="#using-threads-context-class-loader"></a>2.3.7. Using Thread&#8217;s Context Class Loader</h4>
<div class="paragraph">
<p>The build step will be run with a TCCL that can load user classes from the deployment in a transformer-safe way. This class loader only lasts for the life of the augmentation, and is discarded afterwards. The classes will be loaded again in a different class loader at runtime. This means that loading a class during augmentation does not stop it from being transformed when running in the development/test mode.</p>
</div>
</div>
<div class="sect3">
<h4 id="adding-external-jars-to-the-indexer-with-indexdependencybuilditem"><a class="anchor" href="#adding-external-jars-to-the-indexer-with-indexdependencybuilditem"></a>2.3.8. Adding external JARs to the indexer with IndexDependencyBuildItem</h4>
<div class="paragraph">
<p>The index of scanned classes will not automatically include your external class dependencies. To add dependencies, create a <code>@BuildStep</code> that produces <code>IndexDependencyBuildItem</code> objects, for a <code>groupId</code> and <code>artifactId</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to specify all the required artifacts to be added to the indexer. No artifacts are implicitly added transitively.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Amazon Alexa</code> extension adds dependent libraries from the Alexa SDK that are used in Jackson JSON transformations, in order for the reflective classes to identified and included at <code>BUILD_TIME</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">   @BuildStep
    void addDependencies(BuildProducer&lt;IndexDependencyBuildItem&gt; indexDependency) {
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-runtime"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-model"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-lambda-support"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-servlet-support"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-dynamodb-persistence-adapter"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-apache-client"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-model-runtime"));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the artifacts added to the <code>Jandex</code> indexer, you can now search the index to identify classes implementing an interface, sub-classes of a specific class, or classes with a target annotation.</p>
</div>
<div class="paragraph">
<p>For example, the <code>Jackson</code> extension uses code like below to search for annotations used in JSON deserialization, and add them to the reflective hierarchy for <code>BUILD_TIME</code> analysis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class.getName());

    IndexView index = combinedIndexBuildItem.getIndex();

    // handle the various @JsonDeserialize cases
    for (AnnotationInstance deserializeInstance : index.getAnnotations(JSON_DESERIALIZE)) {
        AnnotationTarget annotationTarget = deserializeInstance.target();
        if (CLASS.equals(annotationTarget.kind())) {
            DotName dotName = annotationTarget.asClass().name();
            Type jandexType = Type.create(dotName, Type.Kind.CLASS);
            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));
        }

    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ビルドステップの依存関係の可視化"><a class="anchor" href="#ビルドステップの依存関係の可視化"></a>2.3.9. ビルドステップの依存関係の可視化</h4>
<div class="paragraph">
<p>It can occasionally be useful to see a visual representation of the interactions between the various build steps. For such cases, adding <code>-Djboss.builder.graph-output=build.dot</code> when building an application will result in the creation of the <code>build.dot</code> file in the project&#8217;s root directory. See <a href="https://graphviz.org/resources/">this</a> for a list of software that can open the file and show the actual visual representation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration"><a class="anchor" href="#configuration"></a>2.4. 設定</h3>
<div class="paragraph">
<p>Configuration in Quarkus is based on SmallRye Config, an implementation of the MicroProfile Config specification. All of the standard features of MP-Config are supported; in addition, there are several extensions which are made available by the SmallRye Config project as well as by Quarkus itself.</p>
</div>
<div class="paragraph">
<p>The value of these properties is configured in a <code>application.properties</code> file that follows the MicroProfile config format.</p>
</div>
<div class="paragraph">
<p>Configuration of Quarkus extensions is injection-based, using annotations.</p>
</div>
<div class="sect3">
<h4 id="設定キー"><a class="anchor" href="#設定キー"></a>2.4.1. 設定キー</h4>
<div class="paragraph">
<p>Leaf configuration keys are mapped to non-<code>private</code> fields via the <code>@io.quarkus.runtime.annotations.ConfigItem</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Though the SmallRye Config project is used for implementation, the standard <code>@ConfigProperty</code> annotation does not have the same semantics that are needed to support configuration within extensions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuration keys are normally derived from the field names that they are tied to. This is done by de-camel-casing the name and then joining the segments with hyphens (<code>-</code>). Some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bindAddress</code> becomes <code>bind-address</code></p>
</li>
<li>
<p><code>keepAliveTime</code> becomes <code>keep-alive-time</code></p>
</li>
<li>
<p><code>requestDNSTimeout</code> becomes <code>request-dns-timeout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The name can also be explicitly specified by giving a <code>name</code> attribute to the <code>@ConfigItem</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Though it is possible to override the configuration key name using the <code>name</code> attribute of <code>@ConfigItem</code>, normally this should only be done in cases where (for example) the configuration key name is the same as a Java keyword.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuration-value-types"><a class="anchor" href="#configuration-value-types"></a>2.4.2. Configuration Value types</h4>
<div class="paragraph">
<p>The type of the field with the <code>@ConfigItem</code> annotation determines the conversion that is applied to it. Quarkus extensions may use the full range of configuration types made available by SmallRye Config, which includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All primitive types and primitive wrapper types</p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p>Any type which has a constructor accepting a single argument of type <code>String</code> or <code>CharSequence</code></p>
</li>
<li>
<p>Any type which has a static method named <code>of</code> which accepts a single argument of type <code>String</code></p>
</li>
<li>
<p>Any type which has a static method named <code>valueOf</code> or <code>parse</code> which accepts a single argument of type <code>CharSequence</code> or <code>String</code></p>
</li>
<li>
<p><code>java.time.Duration</code></p>
</li>
<li>
<p><code>java.util.regex.Pattern</code></p>
</li>
<li>
<p><code>java.nio.file.Path</code></p>
</li>
<li>
<p><code>io.quarkus.runtime.configuration.MemorySize</code> to represent data sizes</p>
</li>
<li>
<p><code>java.net.InetSocketAddress</code>, <code>java.net.InetAddress</code> and <code>org.wildfly.common.net.CidrAddress</code></p>
</li>
<li>
<p><code>java.util.Locale</code> where the string value is an IETF BCP 47 language tag</p>
</li>
<li>
<p><code>java.nio.charset.Charset</code> where the string value is a canonical name or an alias</p>
</li>
<li>
<p><code>java.time.ZoneId</code> where the string value is parsed via <code>java.time.ZoneId.of(String)</code></p>
</li>
<li>
<p>A <code>List</code> or <code>Optional</code> of any of the above types</p>
</li>
<li>
<p><code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, custom converters may be registered by adding their fully qualified class name in file <code>META-INF/services/org.eclipse.microprofile.config.spi.Converter</code>.</p>
</div>
<div class="paragraph">
<p>Though these implicit converters use reflection, Quarkus will automatically ensure that they are loaded at the appropriate time.</p>
</div>
<div class="sect4">
<h5 id="optional-values"><a class="anchor" href="#optional-values"></a>2.4.2.1. Optional Values</h5>
<div class="paragraph">
<p>If the configuration type is one of the optional types, then empty values are allowed for the configuration key; otherwise, specification of an empty value will result in a configuration error which prevents the application from starting. This is especially relevant to configuration properties of inherently emptiable values such as <code>List</code>, <code>Set</code>, and <code>String</code>. Such value types will never be empty; in the event of an empty value, an empty <code>Optional</code> is always used.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuration-default-values"><a class="anchor" href="#configuration-default-values"></a>2.4.3. Configuration Default Values</h4>
<div class="paragraph">
<p>A configuration item can be marked to have a default value. The default value is used when no matching configuration key is specified in the configuration.</p>
</div>
<div class="paragraph">
<p>Configuration items with a primitive type (such as <code>int</code> or <code>boolean</code>) implicitly use a default value of <code>0</code> or <code>false</code>. The sole exception to this rule is the <code>char</code> type which does not have an implicit default value.</p>
</div>
<div class="paragraph">
<p>A property with a default value is not implicitly optional. If a non-optional configuration item with a default value is explicitly specified to have an empty value, the application will report a configuration error and will not start. If it is desired for a property to have a default value and also be optional, it must have an <code>Optional</code> type as described above.</p>
</div>
</div>
<div class="sect3">
<h4 id="設定グループ"><a class="anchor" href="#設定グループ"></a>2.4.4. 設定グループ</h4>
<div class="paragraph">
<p>Configuration values are always collected into grouping classes which are marked with the <code>@io.quarkus.runtime.annotations.ConfigGroup</code> annotation. These classes contain a field for each key within its group. In addition, configuration groups can be nested.</p>
</div>
<div class="sect4">
<h5 id="optional-configuration-groups"><a class="anchor" href="#optional-configuration-groups"></a>2.4.4.1. Optional Configuration Groups</h5>
<div class="paragraph">
<p>A nested configuration group may be wrapped with an <code>Optional</code> type. In this case, the group is not populated unless one or more properties within that group are specified in the configuration. If the group is populated, then any required properties in the group must also be specified otherwise a configuration error will be reported and the application will not start.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="設定マップ"><a class="anchor" href="#設定マップ"></a>2.4.5. 設定マップ</h4>
<div class="paragraph">
<p>A <code>Map</code> can be used for configuration at any position where a configuration group would be allowed. The key type of such a map <strong>must</strong> be <code>String</code>, and its value may be either a configuration group class or a valid leaf type. The configuration key segment following the map&#8217;s key segment will be used as the key for map values.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuration-roots"><a class="anchor" href="#configuration-roots"></a>2.4.6. 設定ルート</h4>
<div class="paragraph">
<p>Configuration roots are configuration groups that appear in the root of the configuration tree. A configuration property&#8217;s full name is determined by joining the string <code>quarkus.</code> with the hyphenated name of the fields that form the path from the root to the leaf field. For example, if I define a configuration root group called <code>ThreadPool</code>, with a nested group in a field named <code>sizing</code> that in turn contains a field called <code>minSize</code>, the final configuration property will be called <code>quarkus.thread-pool.sizing.min-size</code>.</p>
</div>
<div class="paragraph">
<p>A configuration root&#8217;s name can be given with the <code>name</code> property, or it can be inferred from the class name. If the latter, then the configuration key will be the class name, minus any <code>Config</code> or <code>Configuration</code> suffix, broken up by camel-case, lowercased, and re-joined using hyphens (<code>-</code>).</p>
</div>
<div class="paragraph">
<p>A configuration root&#8217;s class name can contain an extra suffix segment for the case where there are configuration roots for multiple <a href="#Configuration Root Phases">[Configuration Root Phases]</a>. Classes which correspond to the <code>BUILD_TIME</code> and <code>BUILD_AND_RUN_TIME_FIXED</code> may end with <code>BuildTimeConfig</code> or <code>BuildTimeConfiguration</code>, classes which correspond to the <code>RUN_TIME</code> phase may end with <code>RuntimeConfig</code>, <code>RunTimeConfig</code>, <code>RuntimeConfiguration</code> or <code>RunTimeConfiguration</code> while classes which correspond to the <code>BOOTSTRAP</code> configuration may end with <code>BootstrapConfig</code> or <code>BootstrapConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>Note: The current implementation is still using injection site to determine the root set, so to avoid migration problems, it is recommended that the injection site (field or parameter) have the same name as the configuration root class until this change is complete.</p>
</div>
<div class="sect4">
<h5 id="設定ルートフェーズ"><a class="anchor" href="#設定ルートフェーズ"></a>2.4.6.1. 設定ルートフェーズ</h5>
<div class="paragraph">
<p>Configuration roots are strictly bound by configuration phase, and attempting to access a configuration root from outside of its corresponding phase will result in an error. A configuration root dictates when its contained keys are read from configuration, and when they are available to applications. The phases defined by <code>io.quarkus.runtime.annotations.ConfigPhase</code> are as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 53.3336%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">フェーズ名</th>
<th class="tableblock halign-center valign-top">Read &amp; avail. at build time</th>
<th class="tableblock halign-center valign-top">Avail. at run time</th>
<th class="tableblock halign-center valign-top">Read during static init</th>
<th class="tableblock halign-center valign-top">Re-read during startup (native executable)</th>
<th class="tableblock halign-left valign-top">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUILD_TIME</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Appropriate for things which affect build.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUILD_AND_RUN_TIME_FIXED</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Appropriate for things which affect build and must be visible for run time code.  Not read from config at run time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BOOTSTRAP</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used when runtime configuration needs to be obtained from an external system (like <code>Consul</code>), but details of that system need to be configurable (for example Consul&#8217;s URL). The high level way this works is by using the standard Quarkus config sources (such as properties files, system properties, etc.) and producing <code>ConfigSourceProvider</code> objects which are subsequently taken into account by Quarkus when creating the final runtime <code>Config</code> object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RUN_TIME</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not available at build, read at start in all modes.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For all cases other than the <code>BUILD_TIME</code> case, the configuration root class and all of the configuration groups and types contained therein must be located in, or reachable from, the extension&#8217;s run time artifact. Configuration roots of phase <code>BUILD_TIME</code> may be located in or reachable from either of the extension&#8217;s run time or deployment artifacts.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<em>Bootstrap</em> configuration steps are executed during runtime-init <strong>before</strong> any of other runtime steps. This means that code executed as part of this step cannot access anything that gets initialized in runtime init steps (runtime synthetic CDI beans being one such example).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="設定例"><a class="anchor" href="#設定例"></a>2.4.7. 設定例</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import io.quarkus.runtime.annotations.ConfigItem;
import io.quarkus.runtime.annotations.ConfigGroup;
import io.quarkus.runtime.annotations.DefaultConverter

import java.io.File;
import java.util.logging.Level;

@ConfigGroup <i class="conum" data-value="1"></i><b>(1)</b>
public class FileConfig {

    /**
     * Enable logging to a file.
     */
    @ConfigItem(defaultValue = "true")
    boolean enable;

    /**
     * The log format.
     */
    @ConfigItem(defaultValue = "%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{1.}] (%t) %s%e%n")
    String format;

    /**
     * The level of logs to be written into the file.
     */
    @ConfigItem(defaultValue = "ALL")
    Level level;

    /**
     * The name of the file in which logs will be written.
     */
    @ConfigItem(defaultValue = "application.log")
    File path;

}

/**
 * Logging configuration.
 */
@ConfigRoot(phase = ConfigPhase.RUN_TIME) <i class="conum" data-value="2"></i><b>(2)</b>
public class LogConfiguration {

    // ...

    /**
     * Configuration properties for the logging file handler.
     */
    FileConfig file;
}

public class LoggingProcessor {
    // ...

    /**
     * Logging configuration.
     */
    <i class="conum" data-value="3"></i><b>(3)</b>
    LogConfiguration config;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A configuration property name can be split into segments. For example, a property name like <code>quarkus.log.file.enable</code> can be split into the following segments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus</code> - a namespace claimed by Quarkus which is a prefix for all <code>@ConfigRoot</code> classes,</p>
</li>
<li>
<p><code>log</code> - a name segment which corresponds to the <code>LogConfiguration</code> class annotated with <code>@ConfigRoot</code>,</p>
</li>
<li>
<p><code>file</code> - a name segment which corresponds to the <code>file</code> field in this class,</p>
</li>
<li>
<p><code>enabled</code> - a name segment which corresponds to <code>enable</code> field in <code>FileConfig</code> class annotated with <code>@ConfigGroup</code>.</p>
</li>
</ul>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>FileConfig</code> class is annotated with <code>@ConfigGroup</code> to indicate that this is an aggregate configuration object containing a collection of configurable properties, rather than being a simple configuration key type.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@ConfigRoot</code> annotation indicates that this object is a configuration root group, in this case one which corresponds to a <code>log</code> segment. A class name is used to link configuration root group with the segment from a property name. The <code>Configuration</code> part is stripped off from a <code>LogConfiguration</code> class name and the remaining <code>Log</code> is lowercased to become a <code>log</code>. Since all <code>@ConfigRoot</code> annotated classes uses <code>quarkus</code> as a prefix, this finally becomes <code>quarkus.log</code> and represents the properties which names begin with <code>quarkus.log.*</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here the <code>LoggingProcessor</code> injects a <code>LogConfiguration</code> instance automatically by detecting the <code>@ConfigRoot</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A corresponding <code>application.properties</code> for the above example could be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-properties hljs" data-lang="properties">quarkus.log.file.enable=true
quarkus.log.file.level=DEBUG
quarkus.log.file.path=/tmp/debug.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>format</code> is not defined in these properties, the default value from <code>@ConfigItem</code> will be used instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="enhanced-conversion"><a class="anchor" href="#enhanced-conversion"></a>2.4.8. Enhanced conversion</h4>
<div class="paragraph">
<p>You can use enhanced conversion of a config item by using the <code>@ConvertWith</code> annotation which accepts a <code>Converter</code> class object. If the annotation is present on a config item, the implicit or custom built in converter in use will be overridden by the value provided. To do, see the example below which converts <code>YES</code> or <code>NO</code> values to <code>boolean</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@ConfigRoot
public class SomeConfig {
    /**
     * Config item with enhanced converter
     */
    @ConvertWith(YesNoConverter.class) <i class="conum" data-value="1"></i><b>(1)</b>
    @ConfigItem(defaultValue = "NO")
    Boolean answer;


    public static class YesNoConverter implements Converter&lt;Boolean&gt; {

        public YesNoConverter() {}

        @Override
        public Boolean convert(String s) {
            if (s == null || s.isEmpty()) {
                return false;
            }

            switch (s) {
                case "YES":
                    return true;
                case "NO":
                    return false;
            }

            throw new IllegalArgumentException("Unsupported value " + s + " given");
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Override the default <code>Boolean</code> converter and use the provided converter which accepts a <code>YES</code> or <code>NO</code> config values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The corresponding <code>application.properties</code> will look like.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-properties hljs" data-lang="properties">quarkus.some.answer=YES</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>列挙型の値(設定項目)は、デフォルトではスキュード・ケース(ハイフン付き)に変換されます。以下の表は、列挙型名とその正規の同等表現を示しています。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Java enum</th>
<th class="tableblock halign-left valign-top">正規の同等表現</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DISCARD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">discard</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">READ_UNCOMMITTED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">read-uncommitted</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SIGUSR1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sigusr1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaEnum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java-enum</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAKING_LifeDifficult</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">making-life-difficult</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">YeOldeJBoss</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ye-olde-jboss</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">camelCaseEnum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">camel-case-enum</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>暗黙のコンバータまたはカスタム定義されたコンバータに基づくデフォルトの動作を使用するには、設定項目に <code>@DefaultConverter</code> アノテーションを追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@ConfigRoot
public class SomeLogConfig {
    /**
     * The level of logs to be written into the file.
     */
    @DefaultConverter <i class="conum" data-value="1"></i><b>(1)</b>
    @ConfigItem(defaultValue = "ALL")
    Level level;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Level.class</code> enum を変換するには、デフォルトのコンバータ（内蔵またはカスタムコンバータ）を使用します。</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conditional-step-inclusion"><a class="anchor" href="#conditional-step-inclusion"></a>2.5. Conditional Step Inclusion</h3>
<div class="paragraph">
<p>It is possible to only include a given <code>@BuildStep</code> under certain conditions. The <code>@BuildStep</code> annotation has two optional parameters: <code>onlyIf</code> and <code>onlyIfNot</code>. These parameters can be set to one or more classes which implement <code>BooleanSupplier</code>. The build step will only be included when the method returns <code>true</code> (for <code>onlyIf</code>) or <code>false</code> (for <code>onlyIfNot</code>).</p>
</div>
<div class="paragraph">
<p>The condition class can inject <a href="#configuration-roots">configuration roots</a> as long as they belong to a build-time phase. Run time configuration is not available for condition classes.</p>
</div>
<div class="paragraph">
<p>The condition class may also inject a value of type <code>io.quarkus.runtime.LaunchMode</code>. Constructor parameter and field injection is supported.</p>
</div>
<div class="listingblock">
<div class="title">An example of a conditional build step</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep(onlyIf = IsDevMode.class)
LogCategoryBuildItem enableDebugLogging() {
    return new LogCategoryBuildItem("org.your.quarkus.extension", Level.DEBUG);
}

static class IsDevMode implements BooleanSupplier {
    LaunchMode launchMode;

    public boolean getAsBoolean() {
        return launchMode == LaunchMode.DEVELOPMENT;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to make your build step conditional on the presence or absence of another extension, you can use <a href="#capabilities">Capabilities</a> for that.</p>
</div>
</div>
<div class="sect2">
<h3 id="bytecode-recording"><a class="anchor" href="#bytecode-recording"></a>2.6. バイトコードの記録</h3>
<div class="paragraph">
<p>ビルドプロセスの主要なアウトプットの1つは、記録されたバイトコードです。このバイトコードは、実際に実行時環境を設定します。例えば、Undertowを起動するために、出来上がったアプリケーションには、すべてのServletインスタンスを直接登録し、その後Undertowを起動するバイトコードが含まれます。</p>
</div>
<div class="paragraph">
<p>バイトコードを直接書くのは複雑なので、代わりにバイトコードレコーダーを使っています。デプロイメント時には、実際の実行時 ロジックを含むレコーダー オブジェクトが呼び出されますが、これらの呼び出しは通常通りに行われるのではなく、インターセプトされて記録されます (これが名前の由来です)。この記録は、実行時に同じ一連の呼び出しを実行するバイトコードを生成するために使用されます。これは本質的には遅延実行の一形態であり、デプロイメント時に行われた呼び出しが実行時まで延期されます。</p>
</div>
<div class="paragraph">
<p>典型的な「Hello World」タイプの例を見てみましょう。これをQuarkusの方法で行うには、次のようにレコーダーを作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Recorder
class HelloRecorder {

  public void sayHello(String name) {
    System.out.println("Hello" + name);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、このレコーダーを使用するビルドステップを作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Record(RUNTIME_INIT)
@BuildStep
public void helloBuildStep(HelloRecorder recorder) {
    recorder.sayHello("World");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このビルドステップを実行しても、コンソールには何も表示されません。これは、注入された <code>HelloRecorder</code> が、実際にはすべての呼び出しを記録するプロキシであるためです。代わりに、生成されたQuarkusプログラムを実行すると、コンソールに「Hello World」が出力されます。</p>
</div>
<div class="paragraph">
<p>レコーダーのメソッドは値を返すことができますが、その値はプロキシ可能なものでなければなりません（プロキシ不可能なアイテムを返す場合は、 <code>io.quarkus.runtime.RuntimeValue</code> で囲みます）。これらのプロキシは、直接呼び出すことはできませんが、他のレコーダーのメソッドに渡すことができます。これは、他の <code>@BuildStep</code> メソッドも含めて、どのようなレコーダ・メソッドでもよいので、これらのレコーダの呼び出しの結果をラップした <code>BuildItem</code> インスタンスを生成するのが一般的なパターンです。</p>
</div>
<div class="paragraph">
<p>例えば、Servletの配置に任意の変更を加えるために、Undertowは <code>ServletExtensionBuildItem</code> を持っています。これは <code>ServletExtension</code> インスタンスをラップした <code>MultiBuildItem</code> です。他のモジュールのレコーダーから <code>ServletExtension</code> を返すと、Undertowはそれを使用し、Undertowを起動するレコーダー・メソッドに渡すことができます。</p>
</div>
<div class="paragraph">
<p>実行時には、生成された順にバイトコードが呼び出されます。つまり、ビルドステップの依存関係は、生成されたバイトコードが実行される順序を暗黙のうちに制御します。上の例では、 <code>ServletExtensionBuildItem</code> を生成するバイトコードが、それを消費するバイトコードよりも先に実行されることがわかっています。</p>
</div>
<div class="paragraph">
<p>レコーダーに渡すことができるオブジェクトは以下の通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>プリミティブ</p>
</li>
<li>
<p>文字列</p>
</li>
<li>
<p>Class&lt;?&gt; objects</p>
</li>
<li>
<p>前回のレコーダー起動時に返されたオブジェクト</p>
</li>
<li>
<p>Objects with a no-arg constructor and getter/setters for all properties (or public fields)</p>
</li>
<li>
<p>Objects with a constructor annotated with <code>@RecordableConstructor</code> with parameter names that match field names</p>
</li>
<li>
<p><code>io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)</code> メカニズムによる任意のオブジェクト</p>
</li>
<li>
<p>上記の配列、リスト、マップ</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="レコーダーへの設定の注入"><a class="anchor" href="#レコーダーへの設定の注入"></a>2.6.1. レコーダーへの設定の注入</h4>
<div class="paragraph">
<p>Configuration objects with phase <code>RUNTIME</code> or <code>BUILD_AND_RUNTIME_FIXED</code> can be injected into recorders via constructor injection. Just create a constructor that takes the configuration objects the recorder needs. If the recorder has multiple constructors you can annotate the one you want Quarkus to use with <code>@Inject</code>. If the recorder wants to inject runtime config but is also used at static init time then it needs to inject a <code>RuntimeValue&lt;ConfigObject&gt;</code>, this value will only be set when the runtime methods are being invoked.</p>
</div>
</div>
<div class="sect3">
<h4 id="recordercontext"><a class="anchor" href="#recordercontext"></a>2.6.2. RecorderContext</h4>
<div class="paragraph">
<p><code>io.quarkus.deployment.recording.RecorderContext</code> は、バイトコードの記録を強化するためのいくつかの便利なメソッドを提供しています。これには、引数なしのコンストラクタを持たないクラスの作成関数の登録、オブジェクト置換の登録（基本的には、シリアル化不可能なオブジェクトからシリアル化可能なオブジェクトへの変換、およびその逆）、クラスプロキシの作成などがあります。このインターフェースは、 <code>@Record</code> のメソッドにメソッドパラメータとして直接注入することができます。</p>
</div>
<div class="paragraph">
<p>与えられたクラス名で <code>classProxy</code> を呼び出すと、レコーダーのメソッドに渡すことができる <code>Class</code> が作成され、実行時には <code>classProxy</code> に渡された名前のクラスで置き換えられます。これは基本的に、レコーダで明示的にクラスをロードする必要性を避けるための便宜的なものです。</p>
</div>
</div>
<div class="sect3">
<h4 id="ステップ実行時間の出力"><a class="anchor" href="#ステップ実行時間の出力"></a>2.6.3. ステップ実行時間の出力</h4>
<div class="paragraph">
<p>時には、アプリケーションを実行したときに、各スタートアップタスク（各バイトコードの記録結果）にかかる正確な時間を知りたい場合があります。この情報を確認する最も簡単な方法は、 <code>-Dquarkus.debug.print-startup-times=true</code> システムプロパティを付けてQuarkusアプリケーションを起動することです。出力は以下のようになります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: 42ms
Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed in: 4ms
Build step SyntheticBeansProcessor.initRuntime completed in: 0ms
Build step ConfigBuildStep.validateConfigProperties completed in: 1ms
Build step ResteasyStandaloneBuildStep.boot completed in: 95ms
Build step VertxHttpProcessor.initializeRouter completed in: 1ms
Build step VertxHttpProcessor.finalizeRouter completed in: 4ms
Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms
Build step VertxHttpProcessor.openSocket completed in: 93ms
Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="コンテキストと依存性インジェクション"><a class="anchor" href="#コンテキストと依存性インジェクション"></a>2.7. コンテキストと依存性インジェクション</h3>
<div class="sect3">
<h4 id="拡張ポイント"><a class="anchor" href="#拡張ポイント"></a>2.7.1. 拡張ポイント</h4>
<div class="paragraph">
<p>CDIベースのランタイムとして、Quarkusのエクステンションは、多くの場合、エクステンションの動作の一部としてCDI Beanを利用できるようにしています。ただし、Quarkus DIソリューションはCDI Portable Extensionsをサポートしていません。代わりに、Quarkusのエクステンションは、さまざまな <a href="cdi-reference.html">Build Time Extension Point</a>を利用することができます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="quarkus-dev-ui"><a class="anchor" href="#quarkus-dev-ui"></a>2.8. Quarkus Dev UI</h3>
<div class="paragraph">
<p>エクステンションを <a href="dev-ui.html">Quarkus Dev UI</a>に対応させることで、開発者の利便性を高めることができます。</p>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションで定義されたエンドポイント"><a class="anchor" href="#エクステンションで定義されたエンドポイント"></a>2.9. エクステンションで定義されたエンドポイント</h3>
<div class="paragraph">
<p>エクステンションは、Health、Metrics、OpenAPI、Swagger UIなどのエンドポイントと一緒に提供される、アプリケーション以外のエンドポイントを追加することができます。</p>
</div>
<div class="paragraph">
<p><code>NonApplicationRootPathBuildItem</code> を使用して、エンドポイントを定義します:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
RouteBuildItem myExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {
    return nonApplicationRootPathBuildItem.routeBuilder()
                .route("custom-endpoint")
                .handler(new MyCustomHandler())
                .displayOnNotFoundPage()
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記のパスが「/」で始まっていないのは、相対パスであることを示しています。上記のエンドポイントは、設定されたノンアプリケーションエンドポイントのルートからの相対パスで提供されます。アプリケーション以外のエンドポイントのルートは、デフォルトでは <code>/q</code> となっており、結果的にエンドポイントは <code>/q/custom-endpoint</code> にあることになります。</p>
</div>
<div class="paragraph">
<p>Absolute paths are handled differently. If the above called <code>route("/custom-endpoint")</code>, the resulting endpoint will be found at <code>/custom-endpoint</code>.</p>
</div>
<div class="paragraph">
<p>エクステンションがネストした非アプリケーションのエンドポイントを必要とする場合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
RouteBuildItem myNestedExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {
    return nonApplicationRootPathBuildItem.routeBuilder()
                .nestedRoute("custom-endpoint", "deep")
                .handler(new MyCustomHandler())
                .displayOnNotFoundPage()
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given a default non-application endpoint root of <code>/q</code>, this will create an endpoint at <code>/q/custom-endpoint/deep</code>.</p>
</div>
<div class="paragraph">
<p>Absolute paths also have an impact on nested endpoints. If the above called <code>nestedRoute("custom-endpoint", "/deep")</code>, the resulting endpoint will be found at <code>/deep</code>.</p>
</div>
<div class="paragraph">
<p>Refer to the <a href="all-config#quarkus-vertx-http_quarkus.http.non-application-root-path">Quarkus Vertx HTTP configuration reference</a> for details on how the non-application root path is configured.</p>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションヘルスチェック"><a class="anchor" href="#エクステンションヘルスチェック"></a>2.10. エクステンションヘルスチェック</h3>
<div class="paragraph">
<p>ヘルスチェックは <code>quarkus-smallrye-health</code> のエクステンションを介して提供されます。これは、livenessとreadinessのチェック機能の両方を提供します。</p>
</div>
<div class="paragraph">
<p>エクステンションを書くときには、開発者が自分で書かなくても自動的に含まれるようにすることができるエクステンションのヘルスチェックを提供することが有益です。</p>
</div>
<div class="paragraph">
<p>ヘルスチェックを行うためには、以下のようにしましょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-smallrye-health</code> ヘルスチェックを <strong>オプションの</strong> 依存関係としてランタイムモジュールにインポートすることで、ヘルスチェックが含まれていない場合でもアプリケーションのサイズに影響を与えないようにします。</p>
</li>
<li>
<p>Create your health check following the <a href="smallrye-health">SmallRye Health</a> guide. We advise providing only readiness check for an extension (liveness check is designed to express the fact that an application is up and needs to be lightweight).</p>
</li>
<li>
<p>デプロイメントモジュールに <code>quarkus-smallrye-health-spi</code> ライブラリをインポートします。</p>
</li>
<li>
<p>デプロイメントモジュールに、 <code>HealthBuildItem</code> を生成するビルドステップを追加します。</p>
</li>
<li>
<p>Add a way to disable the extension health check via a config item <code>quarkus.&lt;extension&gt;.health.enabled</code> that should be enabled by default.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an example from the Agroal extension that provides a <code>DataSourceHealthCheck</code> to validate the readiness of a datasource.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {
    return new HealthBuildItem("io.quarkus.agroal.runtime.health.DataSourceHealthCheck",
            agroalBuildTimeConfig.healthEnabled);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションメトリクス"><a class="anchor" href="#エクステンションメトリクス"></a>2.11. エクステンションメトリクス</h3>
<div class="paragraph">
<p><code>quarkus-micrometer</code> エクステンションと <code>quarkus-smallrye-metrics</code> エクステンションは、メトリクスを収集するためのサポートを提供します。互換性についての注意点として、 <code>quarkus-micrometer</code> エクステンションは MP Metrics API を Micrometer ライブラリのプリミティブに適応させているので、MP Metrics API に依存しているコードを壊すことなく <code>quarkus-micrometer</code> エクステンションを有効にすることができます。Micrometer が出力するメトリクスは異なることに注意してください。詳細は <code>quarkus-micrometer</code> エクステンションのドキュメントを参照してください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
MP Metrics API の互換性レイヤは、将来的には別のエクステンションに移行する予定です。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two broad patterns that extensions can use to interact with an optional metrics extension to add their own metrics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer pattern: An extension declares a <code>MetricsFactoryConsumerBuildItem</code> and uses that to provide a bytecode recorder to the metrics extension. When the metrics extension has initialized, it will iterate over registered consumers to initialize them with a <code>MetricsFactory</code>. This factory can be used to declare API-agnostic metrics, which can be a good fit for extensions that provide an instrumentable object for gathering statistics (e.g. Hibernate&#8217;s <code>Statistics</code> class).</p>
</li>
<li>
<p>Binder pattern: An extension can opt to use completely different gathering implementations depending on the metrics system. An <code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> build step parameter can be used to declare or otherwise initialize API-specific metrics based on the active metrics extension (e.g. "smallrye-metrics" or "micrometer"). This pattern can be combined with the consumer pattern by using <code>MetricsFactory::metricsSystemSupported()</code> to test the active metrics extension within the recorder.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Remember that support for metrics is optional. Extensions can use an <code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> parameter in their build step to test for the presence of an enabled metrics extension. Consider using additional configuration to control behavior of metrics. Datasource metrics can be expensive, for example, so additional configuration flags are used enable metrics collection on individual datasources.</p>
</div>
<div class="paragraph">
<p>エクステンションのメトリクスを追加するとき、以下のいずれかの状況に陥ることがあります:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>An underlying library used by the extension is using a specific Metrics API directly (either MP Metrics, Micrometer, or some other).</p>
</li>
<li>
<p>An underlying library uses its own mechanism for collecting metrics and makes them available at runtime using its own API, e.g. Hibernate&#8217;s <code>Statistics</code> class, or Vert.x <code>MetricsOptions</code>.</p>
</li>
<li>
<p>An underlying library does not provide metrics (or there is no library at all) and you want to add instrumentation.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="ケース1ライブラリがメトリクスライブラリを直接利用する場合"><a class="anchor" href="#ケース1ライブラリがメトリクスライブラリを直接利用する場合"></a>2.11.1. ケース1：ライブラリがメトリクス・ライブラリを直接利用する場合</h4>
<div class="paragraph">
<p>If the library directly uses a metrics API, there are two options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use an <code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> parameter to test which metrics API is supported (e.g. "smallrye-metrics" or "micrometer") in your build step, and use that to selectively declare or initialize API-specific beans or build items.</p>
</li>
<li>
<p>Create a separate build step that consumes a <code>MetricsFactory</code>, and use the <code>MetricsFactory::metricsSystemSupported()</code> method within the bytecode recorder to initialize required resources if the desired metrics API is supported (e.g. "smallrye-metrics" or "micrometer").</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Extensions may need to provide a fallback if there is no active metrics extension or the extension doesn&#8217;t support the API required by the library.</p>
</div>
</div>
<div class="sect3">
<h4 id="case-2-the-library-provides-its-own-metric-api"><a class="anchor" href="#case-2-the-library-provides-its-own-metric-api"></a>2.11.2. Case 2: The library provides its own metric API</h4>
<div class="paragraph">
<p>There are two examples of a library providing its own metrics API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The extension defines an instrumentable object as Agroal does with <code>io.agroal.api.AgroalDataSourceMetrics</code>, or</p>
</li>
<li>
<p>The extension provides its own abstraction of metrics, as Jaeger does with <code>io.jaegertracing.spi.MetricsFactory</code>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="observing-instrumentable-objects"><a class="anchor" href="#observing-instrumentable-objects"></a>2.11.2.1. Observing instrumentable objects</h5>
<div class="paragraph">
<p>Let&#8217;s take the instrumentable object (<code>io.agroal.api.AgroalDataSourceMetrics</code>) case first. In this case, you can do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Define a <code>BuildStep</code> that produces a <code>MetricsFactoryConsumerBuildItem</code> that uses a <code>RUNTIME_INIT</code> or <code>STATIC_INIT</code> Recorder to define a <code>MetricsFactory</code> consumer. For example, the following creates a <code>MetricsFactoryConsumerBuildItem</code> if and only if metrics are enabled both for Agroal generally, and for a datasource specifically:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
void registerMetrics(AgroalMetricsRecorder recorder,
        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,
        BuildProducer&lt;MetricsFactoryConsumerBuildItem&gt; datasourceMetrics,
        List&lt;AggregatedDataSourceBuildTimeConfigBuildItem&gt; aggregatedDataSourceBuildTimeConfigs) {

    for (AggregatedDataSourceBuildTimeConfigBuildItem aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) {
        // Create a MetricsFactory consumer to register metrics for a data source
        // IFF metrics are enabled globally and for the data source
        // (they are enabled for each data source by default if they are also enabled globally)
        if (dataSourcesBuildTimeConfig.metricsEnabled &amp;&amp;
                aggregatedDataSourceBuildTimeConfig.getJdbcConfig().enableMetrics.orElse(true)) {
            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(
                    recorder.registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));
        }
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>The associated recorder should use the provided <code>MetricsFactory</code> to register metrics. For Agroal, this means using the <code>MetricFactory</code> API to observe <code>io.agroal.api.AgroalDataSourceMetrics</code> methods. For example:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/* RUNTIME_INIT */
public Consumer&lt;MetricsFactory&gt; registerDataSourceMetrics(String dataSourceName) {
    return new Consumer&lt;MetricsFactory&gt;() {
        @Override
        public void accept(MetricsFactory metricsFactory) {
            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? "default" : dataSourceName;
            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName).getMetrics();

            // When using MP Metrics, the builder uses the VENDOR registry by default.
            metricsFactory.builder("agroal.active.count")
                    .description(
                            "Number of active connections. These connections are in use and not available to be acquired.")
                    .tag("datasource", tagValue)
                    .buildGauge(metrics::activeCount);
            ....</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>MetricsFactory</code> provides a fluid builder for registration of metrics, with the final step constructing gauges or counters based on a <code>Supplier</code> or <code>ToDoubleFunction</code>. Timers can either wrap <code>Callable</code>, <code>Runnable</code>, or <code>Supplier</code> implementations, or can use a <code>TimeRecorder</code> to accumulate chunks of time. The underlying metrics extension will create appropriate artifacts to observe or measure the defined functions.</p>
</div>
</div>
<div class="sect4">
<h5 id="using-a-metrics-api-specific-implementation"><a class="anchor" href="#using-a-metrics-api-specific-implementation"></a>2.11.2.2. Using a Metrics API-specific implementation</h5>
<div class="paragraph">
<p>Using metrics-API specific implementations may be preferred in some cases. Jaeger, for example, defines its own metrics interface, <code>io.jaegertracing.spi.MetricsFactory</code>, that it uses to define counters and gauges. A direct mapping from that interface to the metrics system will be the most efficient. In this case, it is important to isolate these specialized implementations and to avoid eager classloading to ensure the metrics API remains an optional, compile-time dependency.</p>
</div>
<div class="paragraph">
<p><code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> can be used in the build step to selectively control initialization of beans or the production of other build items. The Jaeger extension, for example, can use the following to control initialization of specialized Metrics API adapters:</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/* RUNTIME_INIT */
@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig buildTimeConfig, JaegerConfig jaeger,
        ApplicationConfig appConfig, Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability) {

    // Indicates that this extension would like the SSL support to be enabled
    extensionSslNativeSupport.produce(new ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));

    if (buildTimeConfig.enabled) {
        // To avoid dependency creep, use two separate recorder methods for the two metrics systems
        if (buildTimeConfig.metricsEnabled &amp;&amp; metricsCapability.isPresent()) {
            if (metricsCapability.get().metricsSupported(MetricsFactory.MICROMETER)) {
                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);
            } else {
                jdr.registerTracerWithMpMetrics(jaeger, appConfig);
            }
        } else {
            jdr.registerTracerWithoutMetrics(jaeger, appConfig);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A recorder consuming a <code>MetricsFactory</code> can use <code>MetricsFactory::metricsSystemSupported()</code> can be used to control initialization of metrics objects during bytecode recording in a similar way.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ケース3エクステンションコード内でメトリクスを収集する必要がある"><a class="anchor" href="#ケース3エクステンションコード内でメトリクスを収集する必要がある"></a>2.11.3. ケース3：エクステンションコード内でメトリクスを収集する必要がある</h4>
<div class="paragraph">
<p>To define your own metrics from scratch, you have two basic options: Use the generic <code>MetricFactory</code> builders, or follow the binder pattern, and create instrumentation specific to the enabled metrics extension.</p>
</div>
<div class="paragraph">
<p>To use the extension-agnostic <code>MetricFactory</code> API, your processor can define a <code>BuildStep</code> that produces a <code>MetricsFactoryConsumerBuildItem</code> that uses a <code>RUNTIME_INIT</code> or <code>STATIC_INIT</code> Recorder to define a <code>MetricsFactory</code> consumer.</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder recorder) {
    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>+
- The associated recorder should use the provided <code>MetricsFactory</code> to register metrics, for example</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">final LongAdder extensionCounter = new LongAdder();

/* RUNTIME_INIT */
public Consumer&lt;MetricsFactory&gt; registerMetrics() {
    return new Consumer&lt;MetricsFactory&gt;() {
        @Override
        public void accept(MetricsFactory metricsFactory) {
            metricsFactory.builder("my.extension.counter")
                    .buildGauge(extensionCounter::longValue);
            ....</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that metrics extensions are optional. Keep metrics-related initialization isolated from other setup for your extension, and structure your code to avoid eager imports of metrics APIs. Gathering metrics can also be expensive. Consider using additional extension-specific configuration to control behavior of metrics if the presence/absence of metrics support isn&#8217;t sufficient.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションからjson処理をカスタマイズする"><a class="anchor" href="#エクステンションからjson処理をカスタマイズする"></a>2.12. エクステンションからJSON処理をカスタマイズする</h3>
<div class="paragraph">
<p>エクステンションはしばしば、エクステンションが提供する型のシリアライザやデシリアライザを登録する必要があります。</p>
</div>
<div class="paragraph">
<p>このため、Jackson 拡張モジュールと JSON-B 拡張モジュールの両方で、エクステンション内からシリアライザ/デシリアライザを登録する方法を提供しています。</p>
</div>
<div class="paragraph">
<p>すべての人がJSONを必要とするわけではないことを覚えておいてください。そのため、オプションとする必要があります。</p>
</div>
<div class="paragraph">
<p>エクステンションがJSON関連のカスタマイズを提供しようとする場合は、JacksonとJSON-Bの両方のカスタマイズを提供することを強くお勧めします。</p>
</div>
<div class="sect3">
<h4 id="customizing-jackson"><a class="anchor" href="#customizing-jackson"></a>2.12.1. Customizing Jackson</h4>
<div class="paragraph">
<p>まず、エクステンションのランタイムモジュールに <code>quarkus-jackson</code> への <strong>オプションの</strong> 依存関係を追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、Jackson 用のシリアライザまたはデシリアライザ (またはその両方) を作成します。 <code>mongodb-panache</code> のエクステンションで例を見ることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class ObjectIdSerializer extends StdSerializer&lt;ObjectId&gt; {
    public ObjectIdSerializer() {
        super(ObjectId.class);
    }
    @Override
    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)
            throws IOException {
        if (objectId != null) {
            jsonGenerator.writeString(objectId.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add a dependency to <code>quarkus-jackson-spi</code> on your extension&#8217;s deployment module.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jackson-spi&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add a build step to your processor to register a Jackson module via the <code>JacksonModuleBuildItem</code>. You need to name your module in a unique way across all Jackson modules.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
JacksonModuleBuildItem registerJacksonSerDeser() {
    return new JacksonModuleBuildItem.Builder("ObjectIdModule")
                    .add(io.quarkus.mongodb.panache.jackson.ObjectIdSerializer.class.getName(),
                            io.quarkus.mongodb.panache.jackson.ObjectIdDeserializer.class.getName(),
                            ObjectId.class.getName())
                    .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、Jackson エクステンションは、生成されたビルドアイテムを使用して、Jackson 内で自動的にモジュールを登録します。</p>
</div>
<div class="paragraph">
<p>If you need more customization capabilities than registering a module, you can produce a CDI bean that implements <code>io.quarkus.jackson.ObjectMapperCustomizer</code> via an <code>AdditionalBeanBuildItem</code>. More info about customizing Jackson can be found on the JSON guide <a href="rest-json#configuring-json-support">Configuring JSON support</a></p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-json-b"><a class="anchor" href="#customizing-json-b"></a>2.12.2. Customizing JSON-B</h4>
<div class="paragraph">
<p>First, add an <strong>optional</strong> dependency to <code>quarkus-jsonb</code> on your extension&#8217;s runtime module.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then create a serializer and/or a deserializer for JSON-B, an example of which can be seen in the <code>mongodb-panache</code> extension.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class ObjectIdSerializer implements JsonbSerializer&lt;ObjectId&gt; {
    @Override
    public void serialize(ObjectId obj, JsonGenerator generator, SerializationContext ctx) {
        if (obj != null) {
            generator.write(obj.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add a dependency to <code>quarkus-jsonb-spi</code> on your extension&#8217;s deployment module.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jsonb-spi&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add a build step to your processor to register the serializer via the <code>JsonbSerializerBuildItem</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
JsonbSerializerBuildItem registerJsonbSerializer() {
    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb.ObjectIdSerializer.class.getName()));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JSON-B extension will then use the produced build item to register your serializer/deserializer automatically.</p>
</div>
<div class="paragraph">
<p>If you need more customization capabilities than registering a serializer or a deserializer, you can produce a CDI bean that implements <code>io.quarkus.jsonb.JsonbConfigCustomizer</code> via an <code>AdditionalBeanBuildItem</code>. More info about customizing JSON-B can be found on the JSON guide <a href="rest-json#configuring-json-support">Configuring JSON support</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integrating-with-development-mode"><a class="anchor" href="#integrating-with-development-mode"></a>2.13. Integrating with Development Mode</h3>
<div class="paragraph">
<p>There are various APIS that you can use to integrate with development mode, and to get information about the current state.</p>
</div>
<div class="sect3">
<h4 id="handling-restarts"><a class="anchor" href="#handling-restarts"></a>2.13.1. Handling restarts</h4>
<div class="paragraph">
<p>When Quarkus is starting the <code>io.quarkus.deployment.builditem.LiveReloadBuildItem</code> is guaranteed to be present that gives information about this start, in particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Is this a clean start or a live reload</p>
</li>
<li>
<p>If this is a live reload which changed files / classes triggered the reload</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It also provides a global context map you can use to store information between restarts, without needing to resort to static fields.</p>
</div>
</div>
<div class="sect3">
<h4 id="triggering-live-reload"><a class="anchor" href="#triggering-live-reload"></a>2.13.2. Triggering Live Reload</h4>
<div class="paragraph">
<p>Live reload is generally triggered by a HTTP request, however not all applications are HTTP applications and some extensions may want to trigger live reload based on other events. To do this you need to implement <code>io.quarkus.dev.spi.HotReplacementSetup</code> in your runtime module, and add a <code>META-INF/services/io.quarkus.dev.spi.HotReplacementSetup</code> that lists your implementation.</p>
</div>
<div class="paragraph">
<p>On startup the <code>setupHotDeployment</code> method will be called, and you can use the provided <code>io.quarkus.dev.spi.HotReplacementContext</code> to initiate a scan for changed files.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションのテスト"><a class="anchor" href="#エクステンションのテスト"></a>2.14. エクステンションのテスト</h3>
<div class="paragraph">
<p>Quarkus エクステンションのテストは <code>io.quarkus.test.QuarkusUnitTest</code> JUnit 5 拡張モジュールを使用してください。このエクステンションを使用すると、特定の機能をテストする Arquillian スタイルのテストを行うことができます。ユーザーアプリケーションのテストは <code>io.quarkus.test.junit.QuarkusTest</code> を経由して行う必要があるため、ユーザーアプリケーションのテストを目的としたものではありません。主な違いは、 <code>QuarkusTest</code> は実行開始時にアプリケーションを起動するだけで、 <code>QuarkusUnitTest</code> は各テストクラスごとにカスタムの Quarkus アプリケーションを展開するという点です。</p>
</div>
<div class="paragraph">
<p>These tests should be placed in the deployment module, if additional Quarkus modules are required for testing their deployment modules should also be added as test scoped dependencies.</p>
</div>
<div class="paragraph">
<p>Note that <code>QuarkusUnitTest</code> is in the <code>quarkus-junit5-internal</code> module.</p>
</div>
<div class="paragraph">
<p>An example test class may look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.health.test;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;

import javax.enterprise.inject.Instance;
import javax.inject.Inject;

import org.eclipse.microprofile.health.Liveness;
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import io.quarkus.test.QuarkusUnitTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import io.restassured.RestAssured;

public class FailingUnitTest {

    @RegisterExtension                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
    static final QuarkusUnitTest config = new QuarkusUnitTest()
            .setArchiveProducer(() -&gt;
                    ShrinkWrap.create(JavaArchive.class)                                <i class="conum" data-value="2"></i><b>(2)</b>
                            .addClasses(FailingHealthCheck.class)
                            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml")
            );

    @Inject                                                                             <i class="conum" data-value="3"></i><b>(3)</b>
    @Liveness
    Instance&lt;HealthCheck&gt; checks;

    @Test
    public void testHealthServlet() {
        RestAssured.when().get("/q/health").then().statusCode(503);                       <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Test
    public void testHealthBeans() {
        List&lt;HealthCheck&gt; check = new ArrayList&lt;&gt;();                                    <i class="conum" data-value="5"></i><b>(5)</b>
        for (HealthCheck i : checks) {
            check.add(i);
        }
        assertEquals(1, check.size());
        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call().getState());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuarkusUnitTest</code> エクステンションは、静的フィールドと一緒に使用する必要があります。静的でないフィールドで使用した場合、テストアプリケーションは開始されません。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This producer is used to build the application to be tested. It uses Shrinkwrap to create a JavaArchive to test</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>It is possible to inject beans from our test deployment directly into the test case</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This method directly invokes the health check Servlet and verifies the response</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This method uses the injected health check bean to verify it is returning the expected result</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to test that an extension properly fails at build time, use the <code>setExpectedException</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.hibernate.orm;

import io.quarkus.runtime.configuration.ConfigurationException;
import io.quarkus.test.QuarkusUnitTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

public class PersistenceAndQuarkusConfigTest {

    @RegisterExtension
    static QuarkusUnitTest runner = new QuarkusUnitTest()
            .setExpectedException(ConfigurationException.class)                     <i class="conum" data-value="1"></i><b>(1)</b>
            .withApplicationRoot((jar) -&gt; jar
                    .addAsManifestResource("META-INF/some-persistence.xml", "persistence.xml")
                    .addAsResource("application.properties"));

    @Test
    public void testPersistenceAndConfigTest() {
        // should not be called, deployment exception should happen first:
        // it's illegal to have Hibernate configuration properties in both the
        // application.properties and in the persistence.xml
        Assertions.fail();
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>これは、Quarkus のデプロイが特定の例外で失敗することを JUnit に伝えます。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ホットリロードのテスト"><a class="anchor" href="#ホットリロードのテスト"></a>2.15. ホットリロードのテスト</h3>
<div class="paragraph">
<p>開発モードでエクステンションが正しく動作し、アップデートを正しく処理できるかどうかを検証するテストを書くことも可能です。</p>
</div>
<div class="paragraph">
<p>ほとんどのエクステンションでは、これは「箱から出してすぐに」動作しますが、この機能が期待通りに動作しているかどうかを確認するためにスモークテストを行うことをお勧めします。このテストには <code>QuarkusDevModeTest</code> を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ServletChangeTestCase {

    @RegisterExtension
    final static QuarkusDevModeTest test = new QuarkusDevModeTest()
            .setArchiveProducer(new Supplier&lt;&gt;() {
                @Override
                public JavaArchive get() {
                    return ShrinkWrap.create(JavaArchive.class)   <i class="conum" data-value="1"></i><b>(1)</b>
                            .addClass(DevServlet.class)
                            .addAsManifestResource(new StringAsset("Hello Resource"), "resources/file.txt");
                }
            });

    @Test
    public void testServletChange() throws InterruptedException {
        RestAssured.when().get("/dev").then()
                .statusCode(200)
                .body(is("Hello World"));

        test.modifySourceFile("DevServlet.java", new Function&lt;String, String&gt;() {  <i class="conum" data-value="2"></i><b>(2)</b>

            @Override
            public String apply(String s) {
                return s.replace("Hello World", "Hello Quarkus");
            }
        });

        RestAssured.when().get("/dev").then()
                .statusCode(200)
                .body(is("Hello Quarkus"));
    }

    @Test
    public void testAddServlet() throws InterruptedException {
        RestAssured.when().get("/new").then()
                .statusCode(404);

        test.addSourceFile(NewServlet.class);                                       <i class="conum" data-value="3"></i><b>(3)</b>

        RestAssured.when().get("/new").then()
                .statusCode(200)
                .body(is("A new Servlet"));
    }

    @Test
    public void testResourceChange() throws InterruptedException {
        RestAssured.when().get("/file.txt").then()
                .statusCode(200)
                .body(is("Hello Resource"));

        test.modifyResourceFile("META-INF/resources/file.txt", new Function&lt;String, String&gt;() { <i class="conum" data-value="4"></i><b>(4)</b>

            @Override
            public String apply(String s) {
                return "A new resource";
            }
        });

        RestAssured.when().get("file.txt").then()
                .statusCode(200)
                .body(is("A new resource"));
    }

    @Test
    public void testAddResource() throws InterruptedException {

        RestAssured.when().get("/new.txt").then()
                .statusCode(404);

        test.addResourceFile("META-INF/resources/new.txt", "New File");  <i class="conum" data-value="5"></i><b>(5)</b>

        RestAssured.when().get("/new.txt").then()
                .statusCode(200)
                .body(is("New File"));

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This starts the deployment, your test can modify it as part of the test suite. Quarkus will be restarted between each test method so every method starts with a clean deployment.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This method allows you to modify the source of a class file. The old source is passed into the function, and the updated source is returned.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This method adds a new class file to the deployment. The source that is used will be the original source that is part of the current project.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>このメソッドは静的リソースを変更します</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>このメソッドは新しい静的リソースを追加します</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ネイティブ実行可能ファイルのサポート"><a class="anchor" href="#ネイティブ実行可能ファイルのサポート"></a>2.16. ネイティブ実行可能ファイルのサポート</h3>
<div class="paragraph">
<p>There Quarkus provides a lot of build items that control aspects of the native executable build. This allows for extensions to programmatically perform tasks such as registering classes for reflection or adding static resources to the native executable. Some of these build items are listed below:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem</code></dt>
<dd>
<p>ネイティブ実行可能ファイルに静的なリソースをインクルードします。</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem</code></dt>
<dd>
<p>ディレクトリの静的リソースをネイティブ実行可能ファイルにインクルードします。</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem</code></dt>
<dd>
<p>A class that will be reinitialized at runtime by Substrate. This will result in the static initializer running twice.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem</code></dt>
<dd>
<p>ネイティブ実行可能ファイルのビルド時に設定されるシステムプロパティです。</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem</code></dt>
<dd>
<p>Includes a resource bundle in the native executable.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem</code></dt>
<dd>
<p>Registers a class for reflection in Substrate. Constructors are always registered, while methods and fields are optional.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem</code></dt>
<dd>
<p>A class that will be initialized at runtime rather than build time. This will cause the build to fail if the class is initialized as part of the native executable build process, so care must be taken.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem</code></dt>
<dd>
<p>A convenience feature that allows you to control most of the above features from a single build item.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem</code></dt>
<dd>
<p>ネイティブイメージですべての文字セットを有効にすることを示します。</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem</code></dt>
<dd>
<p>A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build. When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the <a href="https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc">native and ssl guide</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="ide-support-tips"><a class="anchor" href="#ide-support-tips"></a>2.17. IDE support tips</h3>
<div class="sect3">
<h4 id="writing-quarkus-extensions-in-eclipse"><a class="anchor" href="#writing-quarkus-extensions-in-eclipse"></a>2.17.1. Writing Quarkus extensions in Eclipse</h4>
<div class="paragraph">
<p>EclipseでQuarkusエクステンションを書く際の唯一の特別な点は、エクステンションのビルドの一部としてAPT（Annotation Processing Tool）が必要であることです。つまり、以下が必要です:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://marketplace.eclipse.org/content/m2e-apt" class="bare">https://marketplace.eclipse.org/content/m2e-apt</a> から <code>m2e-apt</code> をインストール</p>
</li>
<li>
<p><code>pom.xml</code> にこのプロパティを追加します : <code>&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;</code> 。<code>io.quarkus:quarkus-build-parent</code> に依存している場合、既に追加済です。</p>
</li>
<li>
<p>IDEで同時に <code>io.quarkus:quarkus-extension-processor</code> プロジェクトを開いている場合（例えば、QuarkusのソースをチェックアウトしてIDEで開いている場合）、そのプロジェクトを閉じる必要があります。そうしないと、Eclipseはそのプロジェクトに含まれるAPTプラグインを起動しません。</p>
</li>
<li>
<p>エクステンションプロセッサのプロジェクトを閉じたばかりの場合は、Eclipse が Maven リポジトリからエクステンションプロセッサをピックアップするために、他のプロジェクトで <code>Maven &gt; Update Project</code> を必ず実行してください。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="トラブルシューティング-デバッグのヒント"><a class="anchor" href="#トラブルシューティング-デバッグのヒント"></a>2.18. トラブルシューティング / デバッグのヒント</h3>
<div class="sect3">
<h4 id="dump-the-generated-classes-to-the-file-system"><a class="anchor" href="#dump-the-generated-classes-to-the-file-system"></a>2.18.1. 生成・変換されたクラスの検査</h4>
<div class="paragraph">
<p>Quarkusでは、ビルドフェーズで多くのクラスが生成され、多くの場合、既存のクラスも変換されます。エクステンションの開発中に、生成されたバイトコードや変換されたクラスを見ることができるのは、非常に便利なことです。</p>
</div>
<div class="paragraph">
<p><code>quarkus.package.fernflower.enabled</code> プロパティを <code>true</code> に設定すると、Quarkusは <a href="https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine">Fernflowerのデコンパイラ</a>をダウンロードして起動し、その結果をビルドツールの出力の <code>decompiled</code> ディレクトリにダンプします（例えば、Mavenの場合は <code>target/decompiled</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
このプロパティは、通常のプロダクションビルド時にのみ機能します（つまり、devモード/テストでは機能しません）。また、 <code>fast-jar</code> パッケージングタイプが使用されている場合（デフォルトの動作）には、このプロパティは機能しません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>また、生成/変換されたクラスをファイルシステムにダンプして、IDEのデコンパイラなどで後から検査することができる3つのシステム・プロパティがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.debug.generated-classes-dir</code> - Beanのメタデータのような、生成されたクラスをダンプします</p>
</li>
<li>
<p><code>quarkus.debug.transformed-classes-dir</code> - Panache エンティティのような、変換されたクラスをダンプします</p>
</li>
<li>
<p><code>quarkus.debug.generated-sources-dir</code> - to dump the ZIG files; ZIG file is a textual representation of the generated code that is referenced in the stack traces</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらのプロパティは、開発モードやテストの実行時に、生成/変換されたクラスがクラスローダーのメモリ内に保持されているだけの場合に特に有効です。</p>
</div>
<div class="paragraph">
<p>例えば、 <code>quarkus.debug.generated-classes-dir</code> システムプロパティを指定すると、これらのクラスがディスクに書き出され、開発モードで検査できるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The property value could be either an absolute path, such as <code>/home/foo/dump</code> on a Linux machine, or a path relative to the user working directory, i.e. <code>dump</code> corresponds to the <code>{user.dir}/target/dump</code> in the dev mode and <code>{user.dir}/dump</code> when running the tests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You should see a line in the log for each class written to the directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean.class</code></pre>
</div>
</div>
<div class="paragraph">
<p>The property is also honored when running tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-generated-classes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Analogously, you can use the <code>quarkus.debug.transformed-classes-dir</code> and <code>quarkus.debug.transformed-classes-dir</code> properties to dump the relevant output.</p>
</div>
</div>
<div class="sect3">
<h4 id="マルチモジュールのmavenプロジェクトと開発モード"><a class="anchor" href="#マルチモジュールのmavenプロジェクトと開発モード"></a>2.18.2. マルチモジュールのMavenプロジェクトと開発モード</h4>
<div class="paragraph">
<p>example "モジュールを含むマルチモジュールのMavenプロジェクトでエクステンションを開発することはよくあります。しかし、開発モードでサンプルを実行する場合は、ローカルプロジェクトの依存関係を除外するために、 <code>-DnoDeps</code> システムプロパティを使用する必要があります。そうしないと、Quarkusがエクステンションクラスを監視しようとするため、クラスの読み込みに問題が生じる可能性があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw compile quarkus:dev -DnoDeps</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="indexer-does-not-include-your-external-dependency"><a class="anchor" href="#indexer-does-not-include-your-external-dependency"></a>2.18.3. Indexer does not include your external dependency</h4>
<div class="paragraph">
<p>Remember to add <code>IndexDependencyBuildItem</code> artifacts to your <code>@BuildStep</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="サンプルテストエクステンション"><a class="anchor" href="#サンプルテストエクステンション"></a>2.19. サンプルテストエクステンション</h3>
<div class="paragraph">
<p>We have an extension that is used to test for regressions in the extension processing. It is located in <a href="https://github.com/quarkusio/quarkus/tree/main/integration-tests/test-extension/extension" class="bare">https://github.com/quarkusio/quarkus/tree/main/integration-tests/test-extension/extension</a> directory. In this section we touch on some of the tasks an extension author will typically need to perform using the test-extension code to illustrate how the task could be done.</p>
</div>
<div class="sect3">
<h4 id="フィーチャーとケイパビリティ"><a class="anchor" href="#フィーチャーとケイパビリティ"></a>2.19.1. フィーチャーとケイパビリティ</h4>
<div class="sect4">
<h5 id="特徴"><a class="anchor" href="#特徴"></a>2.19.1.1. 特徴</h5>
<div class="paragraph">
<p><em>フィーチャー</em> とは、エクステンションが提供する機能のことです。フィーチャーの名前は、アプリケーションの起動時にログに表示されます。</p>
</div>
<div class="listingblock">
<div class="title">起動時の行の例</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.061s.
2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, test-extension] <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ランタイムイメージにインストールされているフィーチャーのリスト</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>フィーチャーは、 <code>FeatureBuildItem</code> を生成する link:#Build Step Processors[[Build Step Processors]]メソッドで登録することができます。</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#feature()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    FeatureBuildItem feature() {
        return new FeatureBuildItem("test-extension");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>フィーチャー名には小文字のみを使用し、単語はダッシュで区切ります。例： <code>security-jpa</code> 。1 つのエクステンションが提供するフィーチャーは最大でも 1 つで、その名前は一意でなければなりません。複数のエクステンションが同じ名前のフィーチャーを登録した場合、ビルドは失敗します。</p>
</div>
<div class="paragraph">
<p>フィーチャー名は、エクステンションの <code>devtools/common/src/main/filtered/extensions.json</code> エントリのラベルにも対応している必要があります。これにより、スタートアップラインで表示されるフィーチャー名と、Quarkus mavenプラグインを使用してプロジェクトを作成する際にエクステンションを選択するために使用するラベルが一致します。この例は、 <a href="rest-json.html">Writing JSON REST Services</a>ガイドから引用したもので、 <code>resteasy-jackson</code> フィーチャーが参照されています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn io.quarkus.platform:quarkus-maven-plugin:999-SNAPSHOT:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=rest-json \
    -DclassName="org.acme.rest.json.FruitResource" \
    -Dpath="/fruits" \
    -Dextensions="resteasy-reactive,resteasy-reactive-jackson"
cd rest-json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="capabilities"><a class="anchor" href="#capabilities"></a>2.19.1.2. Capabilities</h5>
<div class="paragraph">
<p><em>ケイパビリティ</em> は、他のエクステンションから問い合わせ可能な技術的能力を表します。1つのエクステンションが複数のケイパビリティを提供することも、複数のエクステンションが同じケイパビリティを提供することもできます。デフォルトでは、ケイパビリティはユーザーに表示されません。エクステンションの存在を確認する際には、クラスパスベースのチェックではなく、ケイパビリティを使用する必要があります。</p>
</div>
<div class="paragraph">
<p>ケイパビリティは、 <code>CapabilityBuildItem</code> を生成する link:#Build Step Processors[[Build Step Processors]]メソッドで登録することができます。</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#capability()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    void capabilities(BuildProducer&lt;CapabilityBuildItem&gt; capabilityProducer) {
        capabilityProducer.produce(new CapabilityBuildItem("org.acme.test-transactions"));
        capabilityProducer.produce(new CapabilityBuildItem("org.acme.test-metrics"));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>エクステンションは、 <code>Capabilities</code> ビルドアイテムを使用して、登録されたケイパビリティを消費することができます。</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#doSomeCoolStuff()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    void doSomeCoolStuff(Capabilities capabilities) {
        if (capabilities.isPresent(Capability.TRANSACTIONS)) {
          // do something only if JTA transactions are in...
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Capabilities should follow the naming conventions of Java packages; e.g. <code>io.quarkus.security.jpa</code>. Capabilities provided by core extensions should be listed in the <code>io.quarkus.deployment.Capability</code> enum and their name should always start with the <code>io.quarkus</code> prefix.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bean-defining-annotations"><a class="anchor" href="#bean-defining-annotations"></a>2.19.2. Bean Defining Annotations</h4>
<div class="paragraph">
<p>The CDI layer processes CDI beans that are either explicitly registered or that it discovers based on bean defining annotations as defined in <a href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations">2.5.1. Bean defining annotations</a>. You can expand this set of annotations to include annotations your extension processes using a <code>BeanDefiningAnnotationBuildItem</code> as shown in this <code>TestProcessor#registerBeanDefinningAnnotations</code> example:</p>
</div>
<div class="listingblock">
<div class="title">Register a Bean Defining Annotation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.enterprise.context.ApplicationScoped;
import org.jboss.jandex.DotName;
import io.quarkus.extest.runtime.TestAnnotation;

public final class TestProcessor {
    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());
    static DotName TEST_ANNOTATION_SCOPE = DotName.createSimple(ApplicationScoped.class.getName());

...

    @BuildStep
    BeanDefiningAnnotationBuildItem registerX() {
        <i class="conum" data-value="1"></i><b>(1)</b>
        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, TEST_ANNOTATION_SCOPE);
    }
...
}

/**
 * Marker annotation for test configuration target beans
 */
@Target({ TYPE })
@Retention(RUNTIME)
@Documented
@Inherited
public @interface TestAnnotation {
}

/**
 * A sample bean
 */
@TestAnnotation <i class="conum" data-value="2"></i><b>(2)</b>
public class ConfiguredBean implements IConfigConsumer {

...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Register the annotation class and CDI default scope using the Jandex <code>DotName</code> class.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>ConfiguredBean</code> will be processed by the CDI layer the same as a bean annotated with the CDI standard @ApplicationScoped.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="コンフィグをオブジェクトにパースする"><a class="anchor" href="#コンフィグをオブジェクトにパースする"></a>2.19.3. コンフィグをオブジェクトにパースする</h4>
<div class="paragraph">
<p>エクステンションの主な目的の1つは、動作の設定段階を実行段階から完全に分離することです。フレームワークは起動時に設定の解析や読み込みを行うことが多いですが、これをビルド時に行うことで、xmlパーサーなどのフレームワークへの実行時の依存を減らし、解析にかかる起動時間を短縮することができます。</p>
</div>
<div class="paragraph">
<p>An example of parsing a XML config file using JAXB is shown in the <code>TestProcessor#parseServiceXmlConfig</code> method:
.Parsing an XML Configuration into Runtime XmlConfig Instance</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    @Record(STATIC_INIT)
    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {
        RuntimeServiceBuildItem serviceBuildItem = null;
        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InputStream is = getClass().getResourceAsStream("/config.xml"); <i class="conum" data-value="1"></i><b>(1)</b>
        if (is != null) {
            log.info("Have XmlConfig, loading");
            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <i class="conum" data-value="2"></i><b>(2)</b>
...
        }
        return serviceBuildItem;
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Look for a config.xml classpath resource</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If found, parse using JAXB context for <code>XmlConfig.class</code></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If there was no /config.xml resource available in the build environment, then a null <code>RuntimeServiceBuildItem</code> would be returned and no subsequent logic based on a <code>RuntimeServiceBuildItem</code> being produced would execute.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Typically one is loading a configuration to create some runtime component/service as <code>parseServiceXmlConfig</code> is doing. We will come back to the rest of the behavior in <code>parseServiceXmlConfig</code> in the following <a href="#Manage Non-CDI Service">[Manage Non-CDI Service]</a> section.</p>
</div>
<div class="paragraph">
<p>If for some reason you need to parse the config and use it in other build steps in an extension processor, you would need to create an <code>XmlConfigBuildItem</code> to pass the parsed XmlConfig instance around.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don&#8217;t want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class. We will do this in <a href="#Replacing Classes in the Native Image">[Replacing Classes in the Native Image]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scanning-deployments-using-jandex"><a class="anchor" href="#scanning-deployments-using-jandex"></a>2.19.4. Scanning Deployments Using Jandex</h4>
<div class="paragraph">
<p>エクステンションが、処理が必要なBeanをマークするアノテーションやインターフェースを定義している場合、Javaアノテーション・インデクサーとオフライン・リフレクション・ライブラリであるJandex APIを使って、これらのBeanを見つけることができます。以下の <code>TestProcessor#scanForBeans</code> メソッドは、 <code>IConfigConsumer</code> インターフェースも実装している <code>@TestAnnotation</code> でアノテーションされたビーンを見つける方法を示しています。</p>
</div>
<div class="listingblock">
<div class="title">Example Jandex Usage</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());
...

    @BuildStep
    @Record(STATIC_INIT)
    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem beanArchiveIndex, <i class="conum" data-value="1"></i><b>(1)</b>
            BuildProducer&lt;TestBeanBuildItem&gt; testBeanProducer) {
        IndexView indexView = beanArchiveIndex.getIndex(); <i class="conum" data-value="2"></i><b>(2)</b>
        Collection&lt;AnnotationInstance&gt; testBeans = indexView.getAnnotations(TEST_ANNOTATION); <i class="conum" data-value="3"></i><b>(3)</b>
        for (AnnotationInstance ann : testBeans) {
            ClassInfo beanClassInfo = ann.target().asClass();
            try {
                boolean isConfigConsumer = beanClassInfo.interfaceNames()
                        .stream()
                        .anyMatch(dotName -&gt; dotName.equals(DotName.createSimple(IConfigConsumer.class.getName()))); <i class="conum" data-value="4"></i><b>(4)</b>
                if (isConfigConsumer) {
                    Class&lt;IConfigConsumer&gt; beanClass = (Class&lt;IConfigConsumer&gt;) Class.forName(beanClassInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());
                    testBeanProducer.produce(new TestBeanBuildItem(beanClass)); <i class="conum" data-value="5"></i><b>(5)</b>
                    log.infof("Configured bean: %s", beanClass);
                }
            } catch (ClassNotFoundException e) {
                log.warn("Failed to load bean class", e);
            }
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Depend on a <code>BeanArchiveIndexBuildItem</code> to have the build step be run after the deployment has been indexed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Retrieve the index.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Find all beans annotated with <code>@TestAnnotation</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Determine which of these beans also has the <code>IConfigConsumer</code> interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Save the bean class in a <code>TestBeanBuildItem</code> for use in a latter RUNTIME_INIT build step that will interact with the bean instances.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-extension-beans"><a class="anchor" href="#interacting-with-extension-beans"></a>2.19.5. Interacting With Extension Beans</h4>
<div class="paragraph">
<p>You can use the <code>io.quarkus.arc.runtime.BeanContainer</code> interface to interact with your extension beans. The following <code>configureBeans</code> methods illustrate interacting with the beans scanned for in the previous section:</p>
</div>
<div class="listingblock">
<div class="title">Using CDI BeanContainer Interface</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#configureBeans
    @BuildStep
    @Record(RUNTIME_INIT)
    void configureBeans(TestRecorder recorder, List&lt;TestBeanBuildItem&gt; testBeans, <i class="conum" data-value="1"></i><b>(1)</b>
            BeanContainerBuildItem beanContainer, <i class="conum" data-value="2"></i><b>(2)</b>
            TestRunTimeConfig runTimeConfig) {

        for (TestBeanBuildItem testBeanBuildItem : testBeans) {
            Class&lt;IConfigConsumer&gt; beanClass = testBeanBuildItem.getConfigConsumer();
            recorder.configureBeans(beanContainer.getValue(), beanClass, buildAndRunTimeConfig, runTimeConfig); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }

// TestRecorder#configureBeans
    public void configureBeans(BeanContainer beanContainer, Class&lt;IConfigConsumer&gt; beanClass,
            TestBuildAndRunTimeConfig buildTimeConfig,
            TestRunTimeConfig runTimeConfig) {
        log.info("Begin BeanContainerListener callback\n");
        IConfigConsumer instance = beanContainer.instance(beanClass); <i class="conum" data-value="4"></i><b>(4)</b>
        instance.loadConfig(buildTimeConfig, runTimeConfig); <i class="conum" data-value="5"></i><b>(5)</b>
        log.infof("configureBeans, instance=%s\n", instance);
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Consume the `TestBeanBuildItem`s produced from the scanning build step.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Consume the <code>BeanContainerBuildItem</code> to order this build step to run after the CDI bean container has been created.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call the runtime recorder to record the bean interactions.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Runtime recorder retrieves the bean using its type.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Runtime recorder invokes the <code>IConfigConsumer#loadConfig(&#8230;&#8203;)</code> method passing in the configuration objects with runtime information.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="非cdiサービスの管理"><a class="anchor" href="#非cdiサービスの管理"></a>2.19.6. 非CDIサービスの管理</h4>
<div class="paragraph">
<p>A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime. Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in <a href="#Parsing Config to Objects">[Parsing Config to Objects]</a>. Now we need to create an instance of the service using the configuration. Let&#8217;s return to the <code>TestProcessor#parseServiceXmlConfig</code> method to see how this can be done.</p>
</div>
<div class="listingblock">
<div class="title">非CDIサービスの作成</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#parseServiceXmlConfig
    @BuildStep
    @Record(STATIC_INIT)
    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {
        RuntimeServiceBuildItem serviceBuildItem = null;
        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InputStream is = getClass().getResourceAsStream("/config.xml");
        if (is != null) {
            log.info("Have XmlConfig, loading");
            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);
            log.info("Loaded XmlConfig, creating service");
            RuntimeValue&lt;RuntimeXmlConfigService&gt; service = recorder.initRuntimeService(config); <i class="conum" data-value="1"></i><b>(1)</b>
            serviceBuildItem = new RuntimeServiceBuildItem(service); <i class="conum" data-value="3"></i><b>(3)</b>
        }
        return serviceBuildItem;
    }

// TestRecorder#initRuntimeService
    public RuntimeValue&lt;RuntimeXmlConfigService&gt; initRuntimeService(XmlConfig config) {
        RuntimeXmlConfigService service = new RuntimeXmlConfigService(config); <i class="conum" data-value="2"></i><b>(2)</b>
        return new RuntimeValue&lt;&gt;(service);
    }

// RuntimeServiceBuildItem
    final public class RuntimeServiceBuildItem extends SimpleBuildItem {
    private RuntimeValue&lt;RuntimeXmlConfigService&gt; service;

    public RuntimeServiceBuildItem(RuntimeValue&lt;RuntimeXmlConfigService&gt; service) {
        this.service = service;
    }

    public RuntimeValue&lt;RuntimeXmlConfigService&gt; getService() {
        return service;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Call into the runtime recorder to record the creation of the service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the parsed <code>XmlConfig</code> instance, create an instance of <code>RuntimeXmlConfigService</code> and wrap it in a <code>RuntimeValue</code>. Use a <code>RuntimeValue</code> wrapper for non-interface objects that are non-proxiable.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Wrap the return service value in a <code>RuntimeServiceBuildItem</code> for use in a RUNTIME_INIT build step that will start the service.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="サービスの開始"><a class="anchor" href="#サービスの開始"></a>2.19.6.1. サービスの開始</h5>
<div class="paragraph">
<p>Now that you have recorded the creation of a service during the build phase, you need to record how to start the service at runtime during booting. You do this with a RUNTIME_INIT build step as shown in the <code>TestProcessor#startRuntimeService</code> method.</p>
</div>
<div class="listingblock">
<div class="title">非CDIサービスの開始/停止</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#startRuntimeService
    @BuildStep
    @Record(RUNTIME_INIT)
    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem , <i class="conum" data-value="1"></i><b>(1)</b>
            RuntimeServiceBuildItem serviceBuildItem) throws IOException { <i class="conum" data-value="2"></i><b>(2)</b>
        if (serviceBuildItem != null) {
            log.info("Registering service start");
            recorder.startRuntimeService(shutdownContextBuildItem, serviceBuildItem.getService()); <i class="conum" data-value="3"></i><b>(3)</b>
        } else {
            log.info("No RuntimeServiceBuildItem seen, check config.xml");
        }
        return new ServiceStartBuildItem("RuntimeXmlConfigService"); <i class="conum" data-value="4"></i><b>(4)</b>
    }

// TestRecorder#startRuntimeService
    public void startRuntimeService(ShutdownContext shutdownContext, RuntimeValue&lt;RuntimeXmlConfigService&gt; runtimeValue)
            throws IOException {
        RuntimeXmlConfigService service = runtimeValue.getValue();
        service.startService(); <i class="conum" data-value="5"></i><b>(5)</b>
        shutdownContext.addShutdownTask(service::stopService); <i class="conum" data-value="6"></i><b>(6)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ShutdownContextBuildItemを消費してサービスのシャットダウンを登録します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We consume the previously initialized service captured in <code>RuntimeServiceBuildItem</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call the runtime recorder to record the service start invocation.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Produce a <code>ServiceStartBuildItem</code> to indicate the startup of a service. See <a href="#Startup and Shutdown Events">[Startup and Shutdown Events]</a> for details.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Runtime recorder retrieves the service instance reference and calls its <code>startService</code> method.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Runtime recorder registers an invocation of the service instance <code>stopService</code> method with the Quarkus <code>ShutdownContext</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code for the <code>RuntimeXmlConfigService</code> can be viewed here: {quarkus-blob-url}/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]</p>
</div>
<div class="paragraph">
<p>The testcase for validating that the <code>RuntimeXmlConfigService</code> has started can be found in the <code>testRuntimeXmlConfigService</code> test of <code>ConfiguredBeanTest</code> and <code>NativeImageIT</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="スタートアップとシャットダウンのイベント"><a class="anchor" href="#スタートアップとシャットダウンのイベント"></a>2.19.7. スタートアップとシャットダウンのイベント</h4>
<div class="paragraph">
<p>The Quarkus container supports startup and shutdown lifecycle events to notify components of the container startup and shutdown. There are CDI events fired that components can observe are illustrated in this example:</p>
</div>
<div class="listingblock">
<div class="title">コンテナの起動を観察</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.runtime.ShutdownEvent;
import io.quarkus.runtime.StartupEvent;

public class SomeBean {
    /**
     * Called when the runtime has started
     * @param event
     */
    void onStart(@Observes StartupEvent event) { <i class="conum" data-value="1"></i><b>(1)</b>
        System.out.printf("onStart, event=%s%n", event);
    }

    /**
     * Called when the runtime is shutting down
     * @param event
    */
    void onStop(@Observes ShutdownEvent event) { <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.printf("onStop, event=%s%n", event);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Observe a <code>StartupEvent</code> to be notified the runtime has started.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Observe a <code>ShutdownEvent</code> to be notified when the runtime is going to shutdown.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a <code>ShutdownContext</code> to register a callback to perform shutdown tasks in the <a href="#Starting a Service">[Starting a Service]</a> section. These shutdown tasks would be called after a <code>ShutdownEvent</code> had been sent.</p>
</div>
<div class="paragraph">
<p>A <code>StartupEvent</code> is fired after all <code>io.quarkus.deployment.builditem.ServiceStartBuildItem</code> producers have been consumed. The implication of this is that if an extension has services that application components would expect to have been started when they observe a <code>StartupEvent</code>, the build steps that invoke the runtime code to start those services needs to produce a <code>ServiceStartBuildItem</code> to ensure that the runtime code is run before the <code>StartupEvent</code> is sent. Recall that we saw the production of a <code>ServiceStartBuildItem</code> in the previous section, and it is repeated here for clarity:</p>
</div>
<div class="listingblock">
<div class="title">Example of Producing a ServiceStartBuildItem</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#startRuntimeService
    @BuildStep
    @Record(RUNTIME_INIT)
    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem,
            RuntimeServiceBuildItem serviceBuildItem) throws IOException {
...
        return new ServiceStartBuildItem("RuntimeXmlConfigService"); <i class="conum" data-value="1"></i><b>(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Produce a <code>ServiceStartBuildItem</code> to indicate that this is a service starting step that needs to run before the <code>StartupEvent</code> is sent.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="register-resources-for-use-in-native-image"><a class="anchor" href="#register-resources-for-use-in-native-image"></a>2.19.8. Register Resources for Use in Native Image</h4>
<div class="paragraph">
<p>Not all configuration or resources can be consumed at build time. If you have classpath resources that the runtime needs to access, you need to inform the build phase that these resources need to be copied into the native image. This is done by producing one or more <code>NativeImageResourceBuildItem</code> or <code>NativeImageResourceBundleBuildItem</code> in the case of resource bundles. Examples of this are shown in this sample <code>registerNativeImageResources</code> build step:</p>
</div>
<div class="listingblock">
<div class="title">Registering Resources and ResourceBundles</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {
    @Inject
    BuildProducer&lt;NativeImageResourceBuildItem&gt; resource;
    @Inject
    BuildProducer&lt;NativeImageResourceBundleBuildItem&gt; resourceBundle;

    @BuildStep
    void registerNativeImageResources() {
        resource.produce(new NativeImageResourceBuildItem("/security/runtime.keys")); <i class="conum" data-value="1"></i><b>(1)</b>

        resource.produce(new NativeImageResourceBuildItem(
                "META-INF/my-descriptor.xml")); <i class="conum" data-value="2"></i><b>(2)</b>

        resourceBundle.produce(new NativeImageResourceBuildItem("javax.xml.bind.Messages")); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate that the /security/runtime.keys classpath resource should be copied into native image.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indicate that the <code>META-INF/my-descriptor.xml</code> resource should be copied into native image</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indicate that the "javax.xml.bind.Messages" resource bundle should be copied into native image.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="service-files"><a class="anchor" href="#service-files"></a>2.19.9. Service files</h4>
<div class="paragraph">
<p>If you are using <code>META-INF/services</code> files you need to register the files as resources so that your native image can find them, but you also need to register each listed class for reflection so they can be instantiated or inspected at run-time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {

    @BuildStep
    void registerNativeImageResources(BuildProducer&lt;ServiceProviderBuildItem&gt; services) {
        String service = "META-INF/services/" + io.quarkus.SomeService.class.getName();

        // find out all the implementation classes listed in the service files
        Set&lt;String&gt; implementations =
            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),
                                          service);

        // register every listed implementation class so they can be instantiated
        // in native-image at run-time
        services.produce(
            new ServiceProviderBuildItem(io.quarkus.SomeService.class.getName(),
                                         implementations.toArray(new String[0])));
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>ServiceProviderBuildItem</code> takes a list of service implementation classes as parameters: if you are not reading them from the service file, make sure that they correspond to the service file contents because the service file will still be read and used at run-time. This is not a substitute for writing a service file.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This only registers the implementation classes for instantiation via reflection (you will not be able to inspect its fields and methods). If you need to do that, you can do it this way:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {

    @BuildStep
    void registerNativeImageResources(BuildProducer&lt;NativeImageResourceBuildItem&gt; resource,
                                     BuildProducer&lt;ReflectiveClassBuildItem&gt; reflectionClasses) {
        String service = "META-INF/services/" + io.quarkus.SomeService.class.getName();

        // register the service file so it is visible in native-image
        resource.produce(new NativeImageResourceBuildItem(service));

        // register every listed implementation class so they can be inspected/instantiated
        // in native-image at run-time
        Set&lt;String&gt; implementations =
            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),
                                          service);
        reflectionClasses.produce(
            new ReflectiveClassBuildItem(true, true, implementations.toArray(new String[0])));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While this is the easiest way to get your services running natively, it&#8217;s less efficient than scanning the implementation classes at build time and generating code that registers them at static-init time instead of relying on reflection.</p>
</div>
<div class="paragraph">
<p>You can achieve that by adapting the previous build step to use a static-init recorder instead of registering classes for reflection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {

    @BuildStep
    @Record(ExecutionTime.STATIC_INIT)
    void registerNativeImageResources(RecorderContext recorderContext,
                                     SomeServiceRecorder recorder) {
        String service = "META-INF/services/" + io.quarkus.SomeService.class.getName();

        // read the implementation classes
        Collection&lt;Class&lt;? extends io.quarkus.SomeService&gt;&gt; implementationClasses = new LinkedHashSet&lt;&gt;();
        Set&lt;String&gt; implementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),
                                                                    service);
        for(String implementation : implementations) {
            implementationClasses.add((Class&lt;? extends io.quarkus.SomeService&gt;)
                recorderContext.classProxy(implementation));
        }

        // produce a static-initializer with those classes
        recorder.configure(implementationClasses);
    }
}

@Recorder
public class SomeServiceRecorder {

    public void configure(List&lt;Class&lt;? extends io.quarkus.SomeService&gt;&gt; implementations) {
        // configure our service statically
        SomeServiceProvider serviceProvider = SomeServiceProvider.instance();
        SomeServiceBuilder builder = serviceProvider.getSomeServiceBuilder();

        List&lt;io.quarkus.SomeService&gt; services = new ArrayList&lt;&gt;(implementations.size());
        // instantiate the service implementations
        for (Class&lt;? extends io.quarkus.SomeService&gt; implementationClass : implementations) {
            try {
                services.add(implementationClass.getConstructor().newInstance());
            } catch (Exception e) {
                throw new IllegalArgumentException("Unable to instantiate service " + implementationClass, e);
            }
        }

        // build our service
        builder.withSomeServices(implementations.toArray(new io.quarkus.SomeService[0]));
        ServiceManager serviceManager = builder.build();

        // register it
        serviceProvider.registerServiceManager(serviceManager, Thread.currentThread().getContextClassLoader());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="オブジェクトの置換"><a class="anchor" href="#オブジェクトの置換"></a>2.19.10. オブジェクトの置換</h4>
<div class="paragraph">
<p>Objects created during the build phase that are passed into the runtime need to have a default constructor in order for them to be created and configured at startup of the runtime from the build time state. If an object does not have a default constructor you will see an error similar to the following during generation of the augmented artifacts:</p>
</div>
<div class="listingblock">
<div class="title">DSAPublicKey Serialization Error</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">	[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build threw an exception: java.lang.RuntimeException: Unable to serialize objects of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has no default constructor
	at io.quarkus.builder.Execution.run(Execution.java:123)
	at io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder.java:136)
	at io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)
	at io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)
	... 36 more</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a <code>io.quarkus.runtime.ObjectSubstitution</code> interface that can be implemented to tell Quarkus how to handle such classes. An example implementation for the <code>DSAPublicKey</code> is shown here:</p>
</div>
<div class="listingblock">
<div class="title">DSAPublicKeyObjectSubstitution Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.extest.runtime.subst;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.DSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.logging.Logger;

import io.quarkus.runtime.ObjectSubstitution;

public class DSAPublicKeyObjectSubstitution implements ObjectSubstitution&lt;DSAPublicKey, KeyProxy&gt; {
    private static final Logger log = Logger.getLogger("DSAPublicKeyObjectSubstitution");
    @Override
    public KeyProxy serialize(DSAPublicKey obj) { <i class="conum" data-value="1"></i><b>(1)</b>
        log.info("DSAPublicKeyObjectSubstitution.serialize");
        byte[] encoded = obj.getEncoded();
        KeyProxy proxy = new KeyProxy();
        proxy.setContent(encoded);
        return proxy;
    }

    @Override
    public DSAPublicKey deserialize(KeyProxy obj) { <i class="conum" data-value="2"></i><b>(2)</b>
        log.info("DSAPublicKeyObjectSubstitution.deserialize");
        byte[] encoded = obj.getContent();
        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);
        DSAPublicKey dsaPublicKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance("DSA");
            dsaPublicKey = (DSAPublicKey) kf.generatePublic(publicKeySpec);

        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return dsaPublicKey;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The serialize method takes the object without a default constructor and creates a <code>KeyProxy</code> that contains the information necessary to recreate the <code>DSAPublicKey</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The deserialize method uses the <code>KeyProxy</code> to recreate the <code>DSAPublicKey</code> from its encoded form using the key factory.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An extension registers this substitution by producing an <code>ObjectSubstitutionBuildItem</code> as shown in this <code>TestProcessor#loadDSAPublicKey</code> fragment:</p>
</div>
<div class="listingblock">
<div class="title">オブジェクト置換の登録</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    @Record(STATIC_INIT)
    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,
            BuildProducer&lt;ObjectSubstitutionBuildItem&gt; substitutions) throws IOException, GeneralSecurityException {
...
        // Register how to serialize DSAPublicKey
        ObjectSubstitutionBuildItem.Holder&lt;DSAPublicKey, KeyProxy&gt; holder = new ObjectSubstitutionBuildItem.Holder(
                DSAPublicKey.class, KeyProxy.class, DSAPublicKeyObjectSubstitution.class);
        ObjectSubstitutionBuildItem keysub = new ObjectSubstitutionBuildItem(holder);
        substitutions.produce(keysub);

        log.info("loadDSAPublicKey run");
        return new PublicKeyBuildItem(publicKey);
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ネイティブイメージにおいてクラスを置換する"><a class="anchor" href="#ネイティブイメージにおいてクラスを置換する"></a>2.19.11. ネイティブイメージにおいてクラスを置換する</h4>
<div class="paragraph">
<p>Graal SDK は、ネイティブイメージ内のクラスの置換をサポートしています。 <code>XmlConfig/XmlData</code> のクラスを、JAXB アノテーションに依存しないバージョンのクラスに置き換える方法の例を以下に示します。</p>
</div>
<div class="listingblock">
<div class="title">Substitution of XmlConfig/XmlData Classes Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.extest.runtime.graal;
import java.util.Date;
import com.oracle.svm.core.annotate.Substitute;
import com.oracle.svm.core.annotate.TargetClass;
import io.quarkus.extest.runtime.config.XmlData;

@TargetClass(XmlConfig.class)
@Substitute
public final class Target_XmlConfig {

    @Substitute
    private String address;
    @Substitute
    private int port;
    @Substitute
    private ArrayList&lt;XData&gt; dataList;

    @Substitute
    public String getAddress() {
        return address;
    }

    @Substitute
    public int getPort() {
        return port;
    }

    @Substitute
    public ArrayList&lt;XData&gt; getDataList() {
        return dataList;
    }

    @Substitute
    @Override
    public String toString() {
        return "Target_XmlConfig{" +
                "address='" + address + '\'' +
                ", port=" + port +
                ", dataList=" + dataList +
                '}';
    }
}

@TargetClass(XmlData.class)
@Substitute
public final class Target_XmlData {

    @Substitute
    private String name;
    @Substitute
    private String model;
    @Substitute
    private Date date;

    @Substitute
    public String getName() {
        return name;
    }

    @Substitute
    public String getModel() {
        return model;
    }

    @Substitute
    public Date getDate() {
        return date;
    }

    @Substitute
    @Override
    public String toString() {
        return "Target_XmlData{" +
                "name='" + name + '\'' +
                ", model='" + model + '\'' +
                ", date='" + date + '\'' +
                '}';
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="設定リファレンスドキュメント"><a class="anchor" href="#設定リファレンスドキュメント"></a>3. 設定リファレンスドキュメント</h2>
<div class="sectionbody">
<div class="paragraph">
<p>設定は各エクステンションの重要な部分なので、適切に文書化する必要があります。それぞれの設定プロパティには、適切な Javadoc コメントが必要です。</p>
</div>
<div class="paragraph">
<p>コーディング時にドキュメントを利用できるようにしておくと便利ですが、この設定ドキュメントはエクステンションガイドでも利用できるようにしておく必要があります。Quarkusのビルドでは、Javadocのコメントに基づいて設定ドキュメントが自動的に生成されますが、ガイドに明示的に含める必要があります。</p>
</div>
<div class="paragraph">
<p>このセクションでは、設定リファレンスドキュメントについて知っておくべきことをすべて説明します。</p>
</div>
<div class="sect2">
<h3 id="ドキュメントの書き方"><a class="anchor" href="#ドキュメントの書き方"></a>3.1. ドキュメントの書き方</h3>
<div class="paragraph">
<p>それぞれの設定プロパティに対して、その目的を説明するJavadocを書く必要があります。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>サマリーテーブルに記載されるので、必ず最初の一文に意味を持たせ、自己完結させましょう。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>標準のJavadocコメントかAsciidocを直接Javadocコメントとして使うことができます。</p>
</div>
<div class="paragraph">
<p>ここでは、Javadocのコメントを書くことに慣れていることを前提としているので、Asciidocのサポートに焦点を当ててみましょう。標準的なJavadocのコメントは単純な文書化には完全に適していますが（推奨されています）、もしあなたがTipsやソースコードの抜粋、リストなどを含めたい場合は、Asciidocが便利です。</p>
</div>
<div class="paragraph">
<p>以下は、Asciidocでコメントされた典型的な設定プロパティです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the
 * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].
 *
 * [NOTE]
 * ====
 * Not all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,
 * MariaDB, Microsoft SQL Server and H2.
 * ====
 *
 * @asciidoclet
 */
@ConfigItem
public Optional&lt;String&gt; dialect;</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは簡単なケースです: Asciidoc を書いて、コメントに <code>@asciidoclet</code> タグを付ければいいだけです。このタグには2つの目的があります: 生成ツールのマーカーとして使用されますが、 <code>javadoc</code> のプロセスで適切な Javadoc 生成のためにも使用されます。</p>
</div>
<div class="paragraph">
<p>では、もう少し複雑な例を考えてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// @formatter:off
/**
 * Name of the file containing the SQL statements to execute when Hibernate ORM starts.
 * Its default value differs depending on the Quarkus launch mode:
 *
 * * In dev and test modes, it defaults to `import.sql`.
 *   Simply add an `import.sql` file in the root of your resources directory
 *   and it will be picked up without having to set this property.
 *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.
 * * In production mode, it defaults to `no-file`.
 *   It means Hibernate ORM won't try to execute any SQL import file by default.
 *   Pass an explicit value to force Hibernate ORM to execute the SQL import file.
 *
 * If you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus
 * https://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].
 *
 * [source,property]
 * .application.properties
 * ----
 * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql
 * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql
 * %prod.quarkus.hibernate-orm.sql-load-script = no-file
 * ----
 *
 * [NOTE]
 * ====
 * Quarkus supports `.sql` file with SQL statements or comments spread over multiple lines.
 * Each SQL statement must be terminated by a semicolon.
 * ====
 *
 * @asciidoclet
 */
// @formatter:on
@ConfigItem
public Optional&lt;String&gt; sqlLoadScript;</code></pre>
</div>
</div>
<div class="paragraph">
<p>これについてのコメントをいくつか。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Javadocのコメントでインデントを尊重する必要がある場合（複数行にまたがるリスト項目やインデントされたソースコードを考えてみてください）には、Eclipseの自動フォーマッタを一時的に無効にする必要があります（これはEclipseを使用していない場合でも同様です。私たちのビルドにはフォーマッタが含まれている為です）。これを行うには、 <code>// @formatter:off</code> / <code>// @formatter:on</code> マーカーを使用してください。これらは別々のコメントであり、 <code>//</code> マーカーの後にスペースがあることに注意してください。これは必須です。</p>
</li>
<li>
<p>見ての通り、Asciidoctorのフルパワーが使えます（以下の制限を除く）</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Asciidoctor のドキュメントでは、オープンブロック ( <code>--</code> ) を使用することはできません。他のすべてのタイプのブロック (ソース、アドミッション&#8230;&#8203;) がサポートされています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>デフォルトでは、doc ジェネレータは <code>java.util.Map</code> 設定項目のキーとしてハイフンで囲まれたフィールド名を使用します。このデフォルトを上書きして（実装の詳細とは無関係に）ユーザーフレンドリーなキーを持つためには、 <code>io.quarkus.runtime.annotations.ConfigDocMapKey</code> アノテーションを使用することができます。以下の例を参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigRoot
public class SomeConfig {
    /**
     * Namespace configuration.
     */
    @ConfigItem(name = ConfigItem.PARENT)
    @ConfigDocMapKey("cache-name") <i class="conum" data-value="1"></i><b>(1)</b>
    Map&lt;String, CaffeineNamespaceConfig&gt; namespace;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>これにより、 <code>quarkus.some."namespace"</code> の代わりに <code>quarkus.some."cache-name"</code> という名前の設定マップキーが生成されます。</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="セクションのドキュメントを書く"><a class="anchor" href="#セクションのドキュメントを書く"></a>3.2. セクションのドキュメントを書く</h3>
<div class="paragraph">
<p>ある <code>@ConfigGroup</code> の設定セクションを生成したい場合は、 <code>@ConfigDocSection</code> アノテーションで対応できます。以下のコード例を参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* Config group related configuration.
* Amazing introduction here
*/
@ConfigItem
@ConfigDocSection <i class="conum" data-value="1"></i><b>(1)</b>
public ConfigGroupConfig configGroup;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This will add a section documentation for the <code>configGroup</code> config item in the generated documentation. Section&#8217;s title and introduction will be derived from the javadoc of the configuration item. The first sentence from the javadoc is considered as the section title and the remaining sentences used as section introduction. You can also use the <code>@asciidoclet</code> tag as shown above.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ドキュメントの生成"><a class="anchor" href="#ドキュメントの生成"></a>3.3. ドキュメントの生成</h3>
<div class="paragraph">
<p>ドキュメントの生成は簡単です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>./mvnw clean install -DskipTests -DskipITs</code> を実行すればOKです。</p>
</li>
<li>
<p>グローバルに行うことも、特定のエクステンションディレクトリ ( <code>extensions/mailer</code> など) で行うこともできます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ドキュメントはプロジェクトのルートにあるグローバル <code>target/asciidoc/generated/config/</code> で生成されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="エクステンションガイドにドキュメントを含める"><a class="anchor" href="#エクステンションガイドにドキュメントを含める"></a>3.4. エクステンションガイドにドキュメントを含める</h3>
<div class="paragraph">
<p>これで、あなたのエクステンションの設定参照ドキュメントが生成されたので、それをガイドに含める必要があります (そして、それをレビューする必要があります)。</p>
</div>
<div class="paragraph">
<p>これは簡単で、ガイドで生成されたドキュメントを含めます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定グループのために生成されたドキュメントを含めたい場合は、以下のinclude文を使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">include::{generated-dir}/config/hyphenated-config-group-class-name-with-runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts=optional, leveloffset=+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>例えば、 <code>io.quarkus.vertx.http.runtime.FormAuthConfig</code> 設定グループは <code>quarkus-vertx-http-config-group-form-auth-config.adoc</code> という名前のファイルに生成されます。</p>
</div>
<div class="paragraph">
<p>幾つかの推奨事項:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>opts=optional</code> は、設定ドキュメントの一部しか生成されていない場合にビルドを失敗させたくないので必須です。</p>
</li>
<li>
<p>ドキュメントはタイトルレベルが2(例: <code>==</code> )で生成されます。通常はこれを調整する必要があります。これは <code>leveloffset=+N</code> で行うことが可能です。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is not recommended to include the whole configuration documentation in the middle of your guide as it&#8217;s heavy. If you have an <code>application.properties</code> extract with your configuration, just do as follows.</p>
</div>
<div class="paragraph">
<p>First, include a tip just below your <code>application.properties</code> extract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">[TIP]
For more information about the extension configuration please refer to the &lt;&lt;configuration-reference, Configuration Reference&gt;&gt;.</code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、文書の最後には、エクステンションのドキュメントをインクルードしてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">[[configuration-reference]]
== 設定リファレンス

include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後にドキュメントを生成して確認します。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecosystem-ci"><a class="anchor" href="#ecosystem-ci"></a>4. エクステンションの継続的なテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>エクステンションの作者が、Quarkusの最新のスナップショットに対して自分の拡張機能を毎日簡単にテストできるようにするために、QuarkusはEcosystem CIという概念を導入しました。Ecosystem CIの <a href="https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc">README</a>には、この機能を利用するためにGitHub Actionsジョブをセットアップする方法の詳細が記載されており、この <a href="https://www.youtube.com/watch?v=VpbRA1n0hHQ">ビデオ</a>ではそのプロセスの概要を説明しています。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="エクステンションを-registry-quarkus-io-で公開"><a class="anchor" href="#エクステンションを-registry-quarkus-io-で公開"></a>5. エクステンションを registry.quarkus.io で公開</h2>
<div class="sectionbody">
<div class="paragraph">
<p>エクステンションを <a href="tooling.html">Quarkusツール</a>に公開する前に、以下の要件が満たされていることを確認してください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-extension.yaml</code> ファイル（エクステンションの <code>runtime/</code> モジュール内）には、最小限のメタデータが設定されています。</p>
<div class="ulist">
<ul>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>description</code> (unless you have it already set in the <code>runtime/pom.xml</code>'s <code>&lt;description&gt;</code> element, which is the recommended approach)</p>
</li>
</ul>
</div>
</li>
<li>
<p>エクステンションがMaven Centralで公開されていること</p>
</li>
<li>
<p>エクステンションのリポジトリは、 <a href="#ecosystem-ci">Ecosystem CI</a>を使用するように設定されていること</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>それから、 <a href="https://github.com/quarkusio/quarkus-extension-catalog">Quarkus Extension Catalog</a>の <code>extensions/</code> ディレクトリに <code>your-extension.yaml</code> ファイルを追加するプルリクエストを作成する必要があります。YAMLは以下のような構造になっていなければなりません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml group-id: <YOUR_EXTENSION_RUNTIME_GROUP_ID> artifact-id: <YOUR_EXTENSION_RUNTIME_ARTIFACT_ID> ``` hljs" data-lang="yaml group-id: <YOUR_EXTENSION_RUNTIME_GROUP_ID> artifact-id: <YOUR_EXTENSION_RUNTIME_ARTIFACT_ID> ```">以上で完了です。プルリクエストがマージされると、スケジュールされたジョブがMaven Centralの新しいバージョンをチェックし、 link:extension-registry-user.html[Quarkus Extension Registry]をアップデートします。</code></pre>
</div>
</div>
</div>
</div>
    </div>
  </div>
</div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus はオープンです。このプロジェクトの全ての依存関係は<a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a>または互換性のあるライセンスの元で利用出来ます。<br /><br />このウェブサイトは <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a> で構築されており、<a href='https://pages.github.com/' target='_blank'>Github Pages</a>にホストされており、完全にオープンソースです。改善したい場合、 <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>ウェブサイトをフォークし</a>、修正してみせてください。</p>

    
      <div class="width-1-12 project-links">
        <span>ナビゲーション</span>
        <ul class="footer-links">
          
            <li><a href="/">ホーム</a></li>
          
            <li><a href="/about">Quarkusについて</a></li>
          
            <li><a href="/blog">ブログ</a></li>
          
            <li><a href="/insights">ポッドキャスト</a></li>
          
            <li><a href="/events">イベント</a></li>
          
            <li><a href="/newsletter">ニュースレター</a></li>
          
            <li><a href="/publications">出版</a></li>
          
            <li><a href="/awards">受賞</a></li>
          
            <li><a href="/security">セキュリティポリシー</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>フォロー</span>
        <ul class="footer-links">
          
            <li><a href="https://twitter.com/quarkusio">Twitter</a></li>
          
            <li><a href="https://www.facebook.com/quarkusio">Facebook</a></li>
          
            <li><a href="https://www.linkedin.com/company/quarkusio/">Linkedin</a></li>
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg">Youtube</a></li>
          
            <li><a href="https://github.com/quarkusio">GitHub</a></li>
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>ヘルプ</span>
        <ul class="footer-links">
          
            <li><a href="/support">サポート</a></li>
          
            <li><a href="/guides">ガイド</a></li>
          
            <li><a href="/faq">FAQ</a></li>
          
            <li><a href="/get-started">入門</a></li>
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus">Stack Overflow</a></li>
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions">ディスカッション</a></li>
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev">開発メーリングリスト</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Languages</span>
        <ul class="footer-links">
          
            <li><a href="https://quarkus.io/">English</a></li>
          
            <li><a href="https://ja.quarkus.io/">Japanese</a></li>
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkusはコミュニティプロジェクトで構成されています：</span>
        <ul class="footer-links">
          
            <li><a href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a href="https://code.quarkus.io/" target="_blank">等々...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a> | <a href="https://www.redhat.com/en/about/privacy-policy">Privacy Policy</a>
    </span>
    <span class="redhat">
      Sponsored by
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/search-filter.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
</body>

</html>
